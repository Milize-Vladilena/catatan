[
  {
    "objectID": "src/modstok/rantai-markov-waktu-kontinu.html",
    "href": "src/modstok/rantai-markov-waktu-kontinu.html",
    "title": "rantai markov waktu kontinu",
    "section": "",
    "text": "Diskrit v.s. Kontinu\nWaktu diskrit: Kejadian terjadi pada titik waktu yang diketahui.\nWaktu kontinu: Kejadian terjadi pada titik sembarang waktu.\nRuang keadaan kontinu ini tetap diskrit meskipun ruang parameter nya kontinu."
  },
  {
    "objectID": "src/modstok/rantai-markov-waktu-kontinu.html#the-transition-probability-function-p_ijt",
    "href": "src/modstok/rantai-markov-waktu-kontinu.html#the-transition-probability-function-p_ijt",
    "title": "rantai markov waktu kontinu",
    "section": "6.4 The Transition Probability Function \\(P_{ij}(t)\\)",
    "text": "6.4 The Transition Probability Function \\(P_{ij}(t)\\)\nLet\n\\[P_{ij}(t) = \\mathbb{P}\\{X(t + s) = j \\mid X(s) = i\\}\\]\ndenote the probability that a process presently in state \\(i\\) will be in state \\(j\\) a time \\(t\\) later. These quantities are often called the transition probabilities of the continuous-time Markov chain.\nWe can explicitly determine \\(P_{ij}(t)\\) in the case of a pure birth process having distinct birth rates. For such a process, let \\(X_k\\) denote the time the process spends in state \\(k\\) before making a transition into state \\(k+1\\), \\(k \\geq 1\\). Suppose that the process is presently in state \\(i\\), and let \\(j &gt; i\\). Then, as \\(X_i\\) is the time it spends in state \\(i\\) before moving to state \\(i+1\\), and \\(X_{i+1}\\) is the time it then spends in state \\(i+1\\) before moving to state \\(i+2\\), and so on, it follows that\n\\[\\sum_{k=i}^{j-1} X_k\\]\nis the time it takes until the process enters state \\(j\\). Now, if the process has not yet entered state \\(j\\) by time \\(t\\), then its state at time \\(t\\) is smaller than \\(j\\), and vice versa. That is,\n\\[X(t) &lt; j \\iff X_i + \\cdots + X_{j-1} &gt; t\\]\nTherefore, for \\(i &lt; j\\), we have for a pure birth process that\n\\[\n\\mathbb{P}\\{X(t) &lt; j \\mid X(0) = i\\} = \\mathbb{P}\\left\\{ \\sum_{k=i}^{j-1} X_k &gt; t \\right\\}\n\\]\nHowever, since \\(X_i, \\ldots, X_{j-1}\\) are independent exponential random variables with respective rates \\(\\lambda_i, \\ldots, \\lambda_{j-1}\\), we obtain from the preceding and Eq. (5.9), which gives the tail distribution function of \\(\\sum_{k=i}^{j-1} X_k\\), that\n\\[\n\\mathbb{P}\\{X(t) &lt; j \\mid X(0) = i\\} = \\sum_{k=i}^{j-1} e^{-\\lambda_k t} \\prod_{\\substack{r=i \\\\ r \\ne k}}^{j-1} \\frac{\\lambda_r}{\\lambda_r - \\lambda_k}\n\\]\nReplacing \\(j\\) by \\(j+1\\) in the preceding gives\n\\[\n\\mathbb{P}\\{X(t) &lt; j+1 \\mid X(0) = i\\} = \\sum_{k=i}^{j} e^{-\\lambda_k t} \\prod_{\\substack{r=i \\\\ r \\ne k}}^{j} \\frac{\\lambda_r}{\\lambda_r - \\lambda_k}\n\\]\nSince\n\\[\n\\mathbb{P}\\{X(t) = j \\mid X(0) = i\\} = \\mathbb{P}\\{X(t) &lt; j+1 \\mid X(0) = i\\} - \\mathbb{P}\\{X(t) &lt; j \\mid X(0) = i\\}\n\\]\nand since \\(P_{ii}(t) = \\mathbb{P}\\{X_i &gt; t\\} = e^{-\\lambda_i t}\\), we have shown the following.\n\nProposition 6.1\nFor a pure birth process having \\(\\lambda_i \\ne \\lambda_j\\) when \\(i \\ne j\\):\n\\[\nP_{ij}(t) = \\sum_{k=i}^{j} e^{-\\lambda_k t} \\prod_{\\substack{r=i \\\\ r \\ne k}}^{j} \\frac{\\lambda_r}{\\lambda_r - \\lambda_k} - \\sum_{k=i}^{j-1} e^{-\\lambda_k t} \\prod_{\\substack{r=i \\\\ r \\ne k}}^{j-1} \\frac{\\lambda_r}{\\lambda_r - \\lambda_k}, \\quad i &lt; j\n\\]\n\\[\nP_{ii}(t) = e^{-\\lambda_i t}\n\\]\n\n\nExample 6.8\nConsider the Yule process, which is a pure birth process in which each individual in the population independently gives birth at rate \\(\\lambda\\), and so \\(\\lambda_n = n\\lambda\\), \\(n \\geq 1\\). Letting \\(i = 1\\), we obtain from Proposition 6.1:\n\\[\nP_{1j}(t) = \\sum_{k=1}^{j} e^{-k\\lambda t} \\prod_{\\substack{r=1 \\\\ r \\ne k}}^{j} \\frac{r}{r - k} - \\sum_{k=1}^{j-1} e^{-k\\lambda t} \\prod_{\\substack{r=1 \\\\ r \\ne k}}^{j-1} \\frac{r}{r - k}\n\\]\nThis simplifies to:\n\\[\nP_{1j}(t) = e^{-j\\lambda t} \\prod_{r=1}^{j-1} \\frac{r}{r - j} + \\sum_{k=1}^{j-1} e^{-k\\lambda t} \\left( \\prod_{\\substack{r=1 \\\\ r \\ne k}}^{j} \\frac{r}{r - k} - \\prod_{\\substack{r=1 \\\\ r \\ne k}}^{j-1} \\frac{r}{r - k} \\right)\n\\]\nWe can further simplify using:\n\\[\n\\frac{k}{j-k} \\prod_{\\substack{r=1 \\\\ r \\ne k}}^{j-1} \\frac{r}{r - k} = \\frac{(j-1)!}{(1-k)(2-k)\\cdots(k-1-k)(j-k)!} = (-1)^{k-1} \\binom{j-1}{k-1}\n\\]\nHence:\n\\[\nP_{1j}(t) = \\sum_{k=1}^{j} \\binom{j-1}{k-1} e^{-k\\lambda t} (-1)^{k-1}\n\\]\nLetting \\(i = j - k\\), and simplifying the index:\n\\[\nP_{1j}(t) = e^{-\\lambda t} \\sum_{i=0}^{j-1} \\binom{j-1}{i} e^{-i\\lambda t} (-1)^i = e^{-\\lambda t} (1 - e^{-\\lambda t})^{j-1}\n\\]\nThus, starting with a single individual, the population size at time \\(t\\) has a geometric distribution with mean \\(e^{\\lambda t}\\). If the population starts with \\(i\\) individuals, then we can regard each of these individuals as starting her own independent Yule process, and so the population at time \\(t\\) will be the sum of \\(i\\) independent and identically distributed geometric random variables with parameter \\(e^{-\\lambda t}\\).\nHence, the population size at time \\(t\\) has a negative binomial distribution with parameters \\(i\\) and \\(e^{-\\lambda t}\\), so:\n\\[\nP_{ij}(t) = \\binom{j-1}{i-1} e^{-i\\lambda t} (1 - e^{-\\lambda t})^{j-i}, \\quad j \\ge i \\ge 1\n\\]\n\n\nExample 6.9\nAn urn initially contains one type 1 and one type 2 ball. At each stage, a ball is chosen from the urn, with the chosen ball being equally likely to be any of the balls in the urn. If a type \\(i\\) ball is chosen, then an experiment that is successful with probability \\(p_i\\) is performed; if it is successful then the ball chosen along with a new type \\(i\\) ball are put in the urn, and if it is unsuccessful then only the ball chosen is put in the urn, \\(i = 1, 2\\). We then move to the next stage.\nWe are interested in determining the mean numbers of type 1 and type 2 balls in the urn after \\(n\\) stages.\nSolution:\nTo determine the mean numbers, for \\(i = 1,2\\), let \\(m_i(j,k:r)\\) denote the mean number of type \\(i\\) balls in the urn after the \\(n\\) stages have elapsed, given that there are currently \\(j\\) type 1 and \\(k\\) type 2 balls in the urn, with a total of \\(r\\) additional stages remaining. Also, let\n\\[\nm(j,k:r) = (m_1(j,k:r), m_2(j,k:r))\n\\]\nWe need to determine \\(m(1,1:n)\\). To start, we derive recursive equations for \\(m(j,k:r)\\) by conditioning on the first ball chosen and whether the resulting experiment is successful. This yields:\n\\[\nm(j,k:r) = \\frac{j}{j+k} [p_1 m(j+1,k:r-1) +\nq_1 m(j,k:r-1)] +\n\\frac{k}{j+k} [p_2 m(j,k+1:r-1) +\nq_2 m(j,k:r-1)]\n\\]\nwhere \\(q_i = 1 - p_i\\), \\(i = 1,2\\).\nUsing the base case: \\[\nm(j,k:0) = (j, k)\n\\]\nwe can use the recursion to determine the values of \\(m(j,k:r)\\) for \\(r = 1\\), then \\(r = 2\\), and so on, up to \\(r = n\\).\n\nWe can also derive an approximation for the mean numbers of type 1 and type 2 balls in the urn after \\(n\\) stages by using a Poissonization trick.\nImagine that each ball in the urn, independently of the others, “lights up” at times distributed as a Poisson process with rate \\(\\lambda = 1\\). Suppose that each time a type \\(i\\) ball lights up, we conduct the experiment that is successful with probability \\(p_i\\), and add a new type \\(i\\) ball to the urn if it is successful.\nEach time a ball lights up, say that a new stage has begun. For an urn with \\(j\\) type 1 and \\(k\\) type 2 balls, the next ball to light up will be of type 1 with probability \\(\\frac{j}{j+k}\\). Thus, the numbers of type 1 and type 2 balls in the urn after successive stages are distributed exactly as in the original model.\nWhenever there are \\(j\\) type 1 balls, the time until the next type 1 ball lights up is the minimum of \\(j\\) independent exponential random variables with rate 1, which is exponential with rate \\(j\\). Since with probability \\(p_1\\) this results in a new type 1 ball being added, the time until the next type 1 ball is added is exponential with rate \\(jp_1\\).\nTherefore, the number of type 1 balls in the urn over time is a Yule process with birth parameters: \\[\n\\lambda_1(j) = jp_1,\\quad j \\ge 1\n\\]\nSimilarly, for type 2: \\[\n\\lambda_2(j) = jp_2,\\quad j \\ge 1\n\\]\nThese two Yule processes are independent.\nLet \\(N_i(t)\\) be the number of type \\(i\\) balls in the urn at time \\(t\\). Then: \\[\nN_i(t) \\sim \\text{Geometric}(1 - e^{-p_i t}) \\Rightarrow \\mathbb{E}[N_i(t)] = e^{p_i t},\\quad i = 1,2\n\\]\nLet \\(L_i(t)\\) be the number of times that a type \\(i\\) ball has lit up by time \\(t\\). Then: \\[\n\\mathbb{E}[N_i(t)] = p_i \\mathbb{E}[L_i(t)] + 1 \\Rightarrow \\mathbb{E}[L_i(t)] = \\frac{e^{p_i t} - 1}{p_i},\\quad i = 1,2\n\\]\nHence, the expected number of stages that have passed by time \\(t\\) is: \\[\n\\mathbb{E}[L_1(t) + L_2(t)] = \\frac{e^{p_1 t} - 1}{p_1} + \\frac{e^{p_2 t} - 1}{p_2}\n\\]\nLet \\(t_n\\) be the value of \\(t\\) that makes the above equal \\(n\\), i.e., \\(t_n\\) solves: \\[\n\\frac{e^{p_1 t_n} - 1}{p_1} + \\frac{e^{p_2 t_n} - 1}{p_2} = n\n\\]\nThen we can approximate the expected number of type \\(i\\) balls in the urn after \\(n\\) stages by: \\[\n\\mathbb{E}[N_i(t_n)] = e^{p_i t_n},\\quad i = 1,2\n\\]\n\nRemarks:\n\nThat \\(\\mathbb{E}[N_i(t)] = p_i \\mathbb{E}[L_i(t)] + 1\\) is not immediate. The number of light ups affects the probability of success (e.g., larger \\(L_i(t)\\) makes success more likely). So in general, \\[\n\\mathbb{E}[N_i(t) \\mid L_i(t)] \\ne p_i L_i(t) + 1\n\\] However, the unconditional expectation formula is correct and can be proven using Wald’s equation, which will be presented in Section 7.3.\nThis example has been applied in drug testing. Suppose there are two drugs with unknown cure probabilities (\\(p_1\\) and \\(p_2\\)). At each stage, a patient receives a drug determined by drawing a ball. If a type \\(i\\) ball is drawn, drug \\(i\\) is used. A successful outcome results in another ball of the same type being added.\nFor \\(p_1 = 0.7\\), \\(p_2 = 0.4\\), after \\(n = 500\\) stages:\n\n\n\nTrue expected number of type 1 balls: 288.92\n\nTrue expected number of type 2 balls: 36.47\n\nApproximate values: 304.09 and 26.23\n\nAfter 1000 stages:\n- True means: 600.77 and 58.28\n- Approximations: 630.37 and 39.79\n\nWe shall now derive a set of differential equations that the transition probabilities \\(P_{ij}(t)\\) satisfy in a general continuous-time Markov chain. However, first we need a definition and a pair of lemmas.\nFor any pair of states \\(i\\) and \\(j\\), let \\[\nq_{ij} = \\nu_i P_{ij}\n\\]\nSince \\(\\nu_i\\) is the rate at which the process makes a transition when in state \\(i\\) and \\(P_{ij}\\) is the probability that this transition is into state \\(j\\), it follows that \\(q_{ij}\\) is the rate, when in state \\(i\\), at which the process makes a transition into state \\(j\\). The quantities \\(q_{ij}\\) are called the instantaneous transition rates.\nSince \\[\n\\nu_i = \\sum_j \\nu_i P_{ij} = \\sum_j q_{ij}\n\\] and \\[\nP_{ij} = \\frac{q_{ij}}{\\nu_i} = \\frac{q_{ij}}{\\sum_j q_{ij}},\n\\] it follows that specifying the instantaneous transition rates determines the parameters of the continuous-time Markov chain.\n\nLemma 6.2.\n(a)\n\\[\n\\lim_{h \\to 0} \\frac{1 - P_{ii}(h)}{h} = \\nu_i\n\\]\n\n\\[\n\\lim_{h \\to 0} \\frac{P_{ij}(h)}{h} = q_{ij}, \\quad \\text{when } i \\ne j\n\\]\n\nProof.\nWe first note that since the amount of time until a transition occurs is exponentially distributed, it follows that the probability of two or more transitions in a time \\(h\\) is \\(o(h)\\) (i.e., vanishes faster than \\(h\\)).\nThus, \\(1 - P_{ii}(h)\\), the probability that a process in state \\(i\\) at time 0 will not be in state \\(i\\) at time \\(h\\), equals the probability that a transition occurs within time \\(h\\) plus something small compared to \\(h\\). Therefore, \\[\n1 - P_{ii}(h) = \\nu_i h + o(h)\n\\] and part (a) is proven.\nTo prove part (b), we note that \\(P_{ij}(h)\\), the probability that the process goes from state \\(i\\) to state \\(j\\) in a time \\(h\\), equals the probability that a transition occurs in this time multiplied by the probability that the transition is into state \\(j\\), plus something small compared to \\(h\\). That is, \\[\nP_{ij}(h) = h \\nu_i P_{ij} + o(h)\n\\] and part (b) is proven. \\(\\blacksquare\\)\n\nLemma 6.3.\nFor all \\(s \\ge 0\\), \\(t \\ge 0\\), \\[\nP_{ij}(t + s) = \\sum_{k=0}^{\\infty} P_{ik}(t) P_{kj}(s) \\tag{6.8}\n\\]\nProof.\nIn order for the process to go from state \\(i\\) to state \\(j\\) in time \\(t + s\\), it must be somewhere at time \\(t\\), and thus: \\[\nP_{ij}(t + s) = \\mathbb{P}\\{X(t + s) = j \\mid X(0) = i\\}\n\\]\nBy the law of total probability: \\[\n= \\sum_{k=0}^{\\infty} \\mathbb{P}\\{X(t + s) = j, X(t) = k \\mid X(0) = i\\}\n\\]\nBy conditional probability: \\[\n= \\sum_{k=0}^{\\infty} \\mathbb{P}\\{X(t + s) = j \\mid X(t) = k, X(0) = i\\} \\cdot \\mathbb{P}\\{X(t) = k \\mid X(0) = i\\}\n\\]\nBy the Markov property: \\[\n= \\sum_{k=0}^{\\infty} \\mathbb{P}\\{X(t + s) = j \\mid X(t) = k\\} \\cdot \\mathbb{P}\\{X(t) = k \\mid X(0) = i\\}\n\\] \\[\n= \\sum_{k=0}^{\\infty} P_{kj}(s) P_{ik}(t)\n\\] and the proof is completed. \\(\\blacksquare\\)\nThe set of equations (6.8) is known as the Chapman–Kolmogorov equations.\nFrom Lemma 6.3, we obtain: \\[\nP_{ij}(h + t) - P_{ij}(t) = \\sum_{k \\ne i} P_{ik}(h) P_{kj}(t) - [1 - P_{ii}(h)] P_{ij}(t)\n\\]\nThus, \\[\n\\frac{P_{ij}(t + h) - P_{ij}(t)}{h} = \\sum_{k \\ne i} \\frac{P_{ik}(h)}{h} P_{kj}(t) - \\frac{1 - P_{ii}(h)}{h} P_{ij}(t)\n\\]\nNow, assuming that we can interchange the limit and the summation, and applying Lemma 6.2: \\[\n\\lim_{h \\to 0} \\frac{P_{ij}(t + h) - P_{ij}(t)}{h} = \\sum_{k \\ne i} q_{ik} P_{kj}(t) - \\nu_i P_{ij}(t)\n\\]\nIt turns out that this interchange can indeed be justified, and hence…\n\n\nTheorem 6.1 (Kolmogorov’s Backward Equations)\nFor all states \\(i, j\\), and times \\(t \\geq 0\\), \\[\n\\frac{d}{dt} P_{ij}(t) = \\sum_{k \\ne i} q_{ik} P_{kj}(t) - \\nu_i P_{ij}(t)\n\\]\n\n\n\nExample 6.10\nThe backward equations for the pure birth process become: \\[\n\\frac{d}{dt} P_{ij}(t) = \\lambda_i P_{i+1,j}(t) - \\lambda_i P_{ij}(t)\n\\]\nThe backward equations for the birth and death process become:\nFor \\(i = 0\\): \\[\n\\frac{d}{dt} P_{0j}(t) = \\lambda_0 [P_{1j}(t) - P_{0j}(t)]\n\\]\nFor \\(i &gt; 0\\): \\[\n\\frac{d}{dt} P_{ij}(t) = \\lambda_i P_{i+1,j}(t) + \\mu_i P_{i-1,j}(t) - (\\lambda_i + \\mu_i) P_{ij}(t) \\tag{6.9}\n\\]\n\n\n\nExample 6.11 (A Continuous-Time Markov Chain Consisting of Two States)\nConsider a machine that works for an exponential amount of time with mean \\(1/\\lambda\\) before breaking down; and suppose that it takes an exponential amount of time with mean \\(1/\\mu\\) to repair the machine.\nLet state 0 = “working”, and state 1 = “under repair”.\nParameters: - \\(\\lambda_0 = \\lambda\\), \\(\\mu_1 = \\mu\\) - \\(\\lambda_i = 0\\) for \\(i \\ne 0\\), \\(\\mu_i = 0\\) for \\(i \\ne 1\\)\nFrom the backward equations: - Equation (6.10): \\[\n  \\frac{d}{dt} P_{00}(t) = \\lambda [P_{10}(t) - P_{00}(t)]\n  \\] - Equation (6.11): \\[\n  \\frac{d}{dt} P_{10}(t) = \\mu P_{00}(t) - \\mu P_{10}(t)\n  \\]\nMultiply (6.10) by \\(\\mu\\), and (6.11) by \\(\\lambda\\), then add: \\[\n\\mu \\frac{d}{dt} P_{00}(t) + \\lambda \\frac{d}{dt} P_{10}(t) = 0\n\\]\nIntegrating: \\[\n\\mu P_{00}(t) + \\lambda P_{10}(t) = \\mu \\tag{6.12}\n\\]\nFrom this, \\[\n\\lambda P_{10}(t) = \\mu[1 - P_{00}(t)]\n\\]\nSubstitute into (6.10): \\[\n\\frac{d}{dt} P_{00}(t) = \\mu[1 - P_{00}(t)] - \\lambda P_{00}(t) = \\mu - (\\mu + \\lambda) P_{00}(t)\n\\]\nLet \\(h(t) = P_{00}(t) - \\frac{\\mu}{\\mu + \\lambda}\\), then: \\[\nh'(t) = -(\\mu + \\lambda) h(t) \\Rightarrow h(t) = K e^{-(\\mu + \\lambda)t}\n\\]\nUse initial condition \\(P_{00}(0) = 1\\): \\[\nP_{00}(t) = \\frac{\\lambda}{\\mu + \\lambda} e^{-(\\mu + \\lambda)t} + \\frac{\\mu}{\\mu + \\lambda}\n\\]\nFrom (6.12), we also get: \\[\nP_{10}(t) = \\frac{\\mu}{\\mu + \\lambda} \\left(1 - e^{-(\\mu + \\lambda)t} \\right)\n\\]\nThus, the probability that the machine is working at time \\(t = 10\\) is: \\[\nP_{00}(10) = \\frac{\\lambda}{\\mu + \\lambda} e^{-10(\\mu + \\lambda)} + \\frac{\\mu}{\\mu + \\lambda}\n\\]\n\n\n\nKolmogorov’s Forward Equations\nFrom the Chapman–Kolmogorov equations: \\[\nP_{ij}(t + h) - P_{ij}(t) = \\sum_{k \\ne j} P_{ik}(t) P_{kj}(h) - [1 - P_{jj}(h)] P_{ij}(t)\n\\]\nDivide by \\(h\\) and take the limit: \\[\n\\frac{d}{dt} P_{ij}(t) = \\sum_{k \\ne j} q_{kj} P_{ik}(t) - \\nu_j P_{ij}(t)\n\\]\nThis leads to the next theorem.\n\n\n\nTheorem 6.2 (Kolmogorov’s Forward Equations)\nUnder suitable regularity conditions, \\[\n\\frac{d}{dt} P_{ij}(t) = \\sum_{k \\ne j} q_{kj} P_{ik}(t) - \\nu_j P_{ij}(t) \\tag{6.13}\n\\]\n\nWe now solve the forward equations for the pure birth process. For this case, (6.13) becomes: \\[\n\\frac{d}{dt} P_{ij}(t) = \\lambda_{j-1} P_{i,j-1}(t) - \\lambda_j P_{ij}(t)\n\\]\nSince \\(P_{ij}(t) = 0\\) when \\(j &lt; i\\), we can write: \\[\n\\frac{d}{dt} P_{ii}(t) = -\\lambda_i P_{ii}(t) \\\\\n\\frac{d}{dt} P_{ij}(t) = \\lambda_{j-1} P_{i,j-1}(t) - \\lambda_j P_{ij}(t), \\quad j \\ge i+1 \\tag{6.14}\n\\]\n\n\n\nProposition 6.4\nFor a pure birth process: \\[\nP_{ii}(t) = e^{-\\lambda_i t}, \\quad i \\ge 0\n\\] \\[\nP_{ij}(t) = \\lambda_{j-1} e^{-\\lambda_j t} \\int_0^t e^{\\lambda_j s} P_{i,j-1}(s) \\, ds, \\quad j \\ge i + 1\n\\]\nProof sketch: Integrate both sides of (6.14) using the integrating factor \\(e^{\\lambda_j t}\\) and initial condition \\(P_{ij}(0) = 0\\).\n\n\n\nExample 6.12 (Forward Equations for Birth and Death Process)\nUsing Eq. (6.13), for the birth-death process we get:\nFor \\(j = 0\\): \\[\n\\frac{d}{dt} P_{i0}(t) = \\mu_1 P_{i1}(t) - \\lambda_0 P_{i0}(t) \\tag{6.15}\n\\]\nFor \\(j \\ge 1\\): \\[\n\\frac{d}{dt} P_{ij}(t) = \\lambda_{j-1} P_{i,j-1}(t) + \\mu_{j+1} P_{i,j+1}(t) - (\\lambda_j + \\mu_j) P_{ij}(t) \\tag{6.16}\n\\]"
  },
  {
    "objectID": "src/metpar/sarima.html",
    "href": "src/metpar/sarima.html",
    "title": "Sarima",
    "section": "",
    "text": "Disini mau belajar model sarima. Detailnya bisa lihat di samping 👉🏼\npdf nya ada di bawah 👇🏼"
  },
  {
    "objectID": "src/metpar/sarima.html#review-model-gabungan-autoregressif-dan-moving-average",
    "href": "src/metpar/sarima.html#review-model-gabungan-autoregressif-dan-moving-average",
    "title": "Sarima",
    "section": "Review Model Gabungan Autoregressif dan moving average",
    "text": "Review Model Gabungan Autoregressif dan moving average\nDalam analisis deret waktu, model yang menggabungkan komponen autoregressive (AR) dan moving average (MA) dikenal sebagai model ARMA dengan orde \\((p, q)\\), yang didefinisikan sebagai berikut:\n\\[\nY_t = \\phi_1 Y_{t-1} + \\phi_2 Y_{t-2} + \\phi_3 Y_{t-3} + \\dots + \\phi_p Y_{t-p} + e_t - \\theta_1 e_{t-1} - \\theta_2 e_{t-2} - \\dots - \\theta_q e_{t-q}\n\\]\ndi mana:\n\n\\(Y_t\\) adalah nilai deret waktu pada waktu ke-\\(t\\),\n\\(e_t\\) adalah white noise (kesalahan acak),\n\\(\\phi_1, \\dots, \\phi_p\\) adalah parameter AR,\n\\(\\theta_1, \\dots, \\theta_q\\) adalah parameter MA.\n\nModel ini disebut sebagai ARMA(p, q)."
  },
  {
    "objectID": "src/metpar/sarima.html#model-arma11",
    "href": "src/metpar/sarima.html#model-arma11",
    "title": "Sarima",
    "section": "Model ARMA(1,1)",
    "text": "Model ARMA(1,1)\nSebagai contoh khusus, kita tinjau model ARMA dengan orde \\(p = 1\\) dan \\(q = 1\\), yaitu:\n\\[\nY_t = \\phi_1 Y_{t-1} + e_t - \\theta_1 e_{t-1}\n\\]\nUntuk menurunkan (derive) persamaan Yule-Walker yang digunakan untuk mengestimasi parameter AR dalam model ARMA, kita dapat memulai dengan mengambil ekspektasi dari hasil perkalian silang antara \\(e_t\\) dan \\(Y_t\\):\n\\[\n\\begin{aligned}\nE(e_t Y_t) &= E\\left[e_t \\left(\\phi_1 Y_{t-1} + e_t - \\theta_1 e_{t-1} \\right) \\right] \\\\\n&= \\phi_1 E(e_t Y_{t-1}) + E(e_t^2) - \\theta_1 E(e_t e_{t-1})\n\\end{aligned}\n\\]\nDengan asumsi bahwa \\(e_t\\) adalah white noise, maka:\n\n\\(E(e_t Y_{t-1}) = 0\\), karena \\(e_t\\) tidak berkorelasi dengan masa lalu.\n\\(E(e_t^2) = \\sigma_e^2\\), yaitu varians dari error.\n\\(E(e_t e_{t-1}) = 0\\), karena white noise tidak berkorelasi dengan lag-nya sendiri.\n\nSehingga diperoleh:\n\\[\nE(e_t Y_t) = \\sigma_e^2\n\\]\nLangkah selanjutnya adalah menurunkan persamaan untuk autokovarians dan autokorelasi menggunakan bentuk ekspektasi ini dan sifat stasioneritas."
  },
  {
    "objectID": "src/metpar/sarima.html#catatan-tambahan",
    "href": "src/metpar/sarima.html#catatan-tambahan",
    "title": "Sarima",
    "section": "Catatan Tambahan",
    "text": "Catatan Tambahan\n\nUntuk model ARMA yang bersifat stasioner, perlu dipastikan bahwa akar dari karakteristik polinomial AR berada di luar lingkaran satuan.\nEstimasi parameter biasanya dilakukan melalui metode Maximum Likelihood Estimation (MLE) atau metode momen, seperti persamaan Yule-Walker untuk komponen AR."
  },
  {
    "objectID": "src/metpar/sarima.html#penurunan-autokovarians-dan-autokorelasi-untuk-arma11",
    "href": "src/metpar/sarima.html#penurunan-autokovarians-dan-autokorelasi-untuk-arma11",
    "title": "Sarima",
    "section": "Penurunan Autokovarians dan Autokorelasi untuk ARMA(1,1)",
    "text": "Penurunan Autokovarians dan Autokorelasi untuk ARMA(1,1)\nDari model:\n\\[\nY_t = \\phi_1 Y_{t-1} + e_t - \\theta_1 e_{t-1}\n\\]\nAsumsikan bahwa prosesnya stasioner, maka kita dapat menurunkan autokovarians dan autokorelasi menggunakan sifat ekspektasi dan definisi berikut:\nMisalkan:\n\n\\(\\gamma(h) = \\text{Cov}(Y_t, Y_{t-h})\\): autokovarians lag-\\(h\\)\n\\(\\rho(h) = \\text{Corr}(Y_t, Y_{t-h}) = \\frac{\\gamma(h)}{\\gamma(0)}\\): autokorelasi lag-\\(h\\)\n\n\n\nAutokovarians Lag 0\n\\[\n\\gamma(0) = \\text{Var}(Y_t)\n\\]\nGunakan model ARMA(1,1):\n\\[\nY_t = \\phi_1 Y_{t-1} + e_t - \\theta_1 e_{t-1}\n\\]\nKita cari variansnya:\n\\[\n\\begin{aligned}\n\\gamma(0) &= \\text{Var}(Y_t) \\\\\n&= \\text{Var}(\\phi_1 Y_{t-1} + e_t - \\theta_1 e_{t-1}) \\\\\n&= \\phi_1^2 \\text{Var}(Y_{t-1}) + \\text{Var}(e_t) + \\theta_1^2 \\text{Var}(e_{t-1}) \\\\\n&\\quad + 2\\phi_1 \\text{Cov}(Y_{t-1}, e_t) - 2\\phi_1 \\theta_1 \\text{Cov}(Y_{t-1}, e_{t-1}) - 2\\theta_1 \\text{Cov}(e_t, e_{t-1})\n\\end{aligned}\n\\]\nGunakan sifat white noise:\n\n\\(\\text{Var}(e_t) = \\sigma_e^2\\)\n\\(\\text{Cov}(e_t, e_{t-1}) = 0\\)\n\\(\\text{Cov}(Y_{t-1}, e_t) = 0\\)\n\\(\\text{Cov}(Y_{t-1}, e_{t-1}) = \\sigma_e^2\\) (karena \\(Y_{t-1}\\) mengandung \\(e_{t-1}\\))\n\nSehingga:\n\\[\n\\begin{aligned}\n\\gamma(0) &= \\phi_1^2 \\gamma(0) + \\sigma_e^2 + \\theta_1^2 \\sigma_e^2 - 2\\phi_1 \\theta_1 \\sigma_e^2 \\\\\n&= \\phi_1^2 \\gamma(0) + \\sigma_e^2(1 + \\theta_1^2 - 2\\phi_1 \\theta_1)\n\\end{aligned}\n\\]\nPindahkan \\(\\phi_1^2 \\gamma(0)\\) ke sisi kiri:\n\\[\n\\gamma(0)(1 - \\phi_1^2) = \\sigma_e^2(1 + \\theta_1^2 - 2\\phi_1 \\theta_1)\n\\]\nSehingga:\n\\[\n\\gamma(0) = \\frac{\\sigma_e^2 (1 + \\theta_1^2 - 2\\phi_1 \\theta_1)}{1 - \\phi_1^2}\n\\]\n\n\n\nAutokovarians Lag 1\nGunakan definisi:\n\\[\n\\gamma(1) = E[(Y_t - \\mu)(Y_{t-1} - \\mu)] = E[Y_t Y_{t-1}] \\quad \\text{(karena } \\mu = 0)\n\\]\nGunakan model:\n\\[\nY_t = \\phi_1 Y_{t-1} + e_t - \\theta_1 e_{t-1}\n\\]\nMaka:\n\\[\n\\begin{aligned}\n\\gamma(1) &= E[(\\phi_1 Y_{t-1} + e_t - \\theta_1 e_{t-1}) Y_{t-1}] \\\\\n&= \\phi_1 E[Y_{t-1}^2] + E[e_t Y_{t-1}] - \\theta_1 E[e_{t-1} Y_{t-1}]\n\\end{aligned}\n\\]\nDengan:\n\n\\(E[Y_{t-1}^2] = \\gamma(0)\\)\n\\(E[e_t Y_{t-1}] = 0\\)\n\\(E[e_{t-1} Y_{t-1}] = \\sigma_e^2\\)\n\nMaka:\n\\[\n\\gamma(1) = \\phi_1 \\gamma(0) - \\theta_1 \\sigma_e^2\n\\]\n\n\n\nAutokorelasi Lag 1\nGunakan definisi:\n\\[\n\\rho(1) = \\frac{\\gamma(1)}{\\gamma(0)} = \\phi_1 - \\theta_1 \\frac{\\sigma_e^2}{\\gamma(0)}\n\\]\nDengan nilai \\(\\gamma(0)\\) yang telah diperoleh sebelumnya, kita bisa hitung eksplisit.\n\nKalau kamu mau, kita bisa lanjut ke:\n\nAutokovarians lag \\(h\\) secara umum,\nPlot ACF/PACF dari ARMA(1,1),\nAtau masuk ke ARIMA dengan differencing.\n\nTinggal bilang saja!"
  },
  {
    "objectID": "src/asum/min-Var-2firm.html",
    "href": "src/asum/min-Var-2firm.html",
    "title": "Minimalkan variansi 2 perusahaan",
    "section": "",
    "text": "Consider two insurance companies A and B which are exposed to aggregate claims \\(S_A\\) and \\(S_B\\), respectively, where \\(S_A\\) and \\(S_B\\) are independent random variables. Let us suppose that the two companies share their risks with each other as follows:\n\nCompany A retains \\(g_1(S_A)\\) and reinsures \\(S_A - g_1(S_A)\\) with company B;\nCompany B retains \\(g_2(S_B)\\) and reinsures \\(S_B - g_2(S_B)\\) with company A,\n\nwhere \\(g_i(\\cdot)\\), \\(i = 1, 2\\), are reinsurance functions (so they satisfy \\(0 \\leq g_i(x) \\leq x\\), \\(i = 1, 2\\)). Then the total payouts for company A and company B are \\(T_A\\) and \\(T_B\\), respectively, where:\n\\[\nT_A = g_1(S_A) + [S_B - g_2(S_B)]\n\\]\n\\[\nT_B = g_2(S_B) + [S_A - g_1(S_A)]\n\\]\nHence, since \\(S_A\\) and \\(S_B\\) are independent, we have:\n\\[\n\\text{Var}[T_A] = \\text{Var}[g_1(S_A)] + \\text{Var}[S_B - g_2(S_B)]\n\\]\n\\[\n\\text{Var}[T_B] = \\text{Var}[g_2(S_B)] + \\text{Var}[S_A - g_1(S_A)]\n\\]\nSuppose the function \\(g_1(\\cdot)\\) does not define a proportional reinsurance arrangement. If we now choose:\n\\[\n\\beta_1 = \\left\\{ \\frac{\\text{Var}[g_1(S_A)]}{\\text{Var}[S_A]} \\right\\}^{1/2}\n\\]\nand define \\(g_1^*(S_A) = \\beta_1 S_A\\), then \\(g_1^*(\\cdot)\\) does define a proportional arrangement and we have:\n\\[\n\\text{Var}[g_1^*(S_A)] = \\text{Var}[g_1(S_A)]\n\\]\nWe know that the variance of the reinsurance payout, subject to fixed variance for the direct insurance payout, is minimised by proportional reinsurance (see §5.7.2), hence:\n\\[\n\\text{Var}[S_A - g_1^*(S_A)] \\leq \\text{Var}[S_A - g_1(S_A)]\n\\]\nA similar argument holds for \\(g_2(\\cdot)\\). Hence \\(\\text{Var}[T_A] + \\text{Var}[T_B]\\) is minimised by both companies using proportional reinsurance.\nIn Exercise 5.31 you are asked to show that the optimal arrangement is in fact that in which each company shares its risk equally with the other.\n\n\n\n\nConsider the situation explored in §5.7.5, in which we seek to minimise the sum of the variances of the payouts when two independent risks are shared between two insurers.\nExtend the argument to show that the optimal arrangement is that in which each company shares its risk equally with the other."
  },
  {
    "objectID": "src/asum/min-Var-2firm.html#ekstraksi-asli-english-from-the-book",
    "href": "src/asum/min-Var-2firm.html#ekstraksi-asli-english-from-the-book",
    "title": "Minimalkan variansi 2 perusahaan",
    "section": "",
    "text": "Consider two insurance companies A and B which are exposed to aggregate claims \\(S_A\\) and \\(S_B\\), respectively, where \\(S_A\\) and \\(S_B\\) are independent random variables. Let us suppose that the two companies share their risks with each other as follows:\n\nCompany A retains \\(g_1(S_A)\\) and reinsures \\(S_A - g_1(S_A)\\) with company B;\nCompany B retains \\(g_2(S_B)\\) and reinsures \\(S_B - g_2(S_B)\\) with company A,\n\nwhere \\(g_i(\\cdot)\\), \\(i = 1, 2\\), are reinsurance functions (so they satisfy \\(0 \\leq g_i(x) \\leq x\\), \\(i = 1, 2\\)). Then the total payouts for company A and company B are \\(T_A\\) and \\(T_B\\), respectively, where:\n\\[\nT_A = g_1(S_A) + [S_B - g_2(S_B)]\n\\]\n\\[\nT_B = g_2(S_B) + [S_A - g_1(S_A)]\n\\]\nHence, since \\(S_A\\) and \\(S_B\\) are independent, we have:\n\\[\n\\text{Var}[T_A] = \\text{Var}[g_1(S_A)] + \\text{Var}[S_B - g_2(S_B)]\n\\]\n\\[\n\\text{Var}[T_B] = \\text{Var}[g_2(S_B)] + \\text{Var}[S_A - g_1(S_A)]\n\\]\nSuppose the function \\(g_1(\\cdot)\\) does not define a proportional reinsurance arrangement. If we now choose:\n\\[\n\\beta_1 = \\left\\{ \\frac{\\text{Var}[g_1(S_A)]}{\\text{Var}[S_A]} \\right\\}^{1/2}\n\\]\nand define \\(g_1^*(S_A) = \\beta_1 S_A\\), then \\(g_1^*(\\cdot)\\) does define a proportional arrangement and we have:\n\\[\n\\text{Var}[g_1^*(S_A)] = \\text{Var}[g_1(S_A)]\n\\]\nWe know that the variance of the reinsurance payout, subject to fixed variance for the direct insurance payout, is minimised by proportional reinsurance (see §5.7.2), hence:\n\\[\n\\text{Var}[S_A - g_1^*(S_A)] \\leq \\text{Var}[S_A - g_1(S_A)]\n\\]\nA similar argument holds for \\(g_2(\\cdot)\\). Hence \\(\\text{Var}[T_A] + \\text{Var}[T_B]\\) is minimised by both companies using proportional reinsurance.\nIn Exercise 5.31 you are asked to show that the optimal arrangement is in fact that in which each company shares its risk equally with the other.\n\n\n\n\nConsider the situation explored in §5.7.5, in which we seek to minimise the sum of the variances of the payouts when two independent risks are shared between two insurers.\nExtend the argument to show that the optimal arrangement is that in which each company shares its risk equally with the other."
  },
  {
    "objectID": "src/asum/min-Var-2firm.html#minimalkan-variansi-saat-dua-risiko-dibagi-ke-dua-perusahaan-asuransi",
    "href": "src/asum/min-Var-2firm.html#minimalkan-variansi-saat-dua-risiko-dibagi-ke-dua-perusahaan-asuransi",
    "title": "Minimalkan variansi 2 perusahaan",
    "section": "🧠 Minimalkan Variansi Saat Dua Risiko Dibagi ke Dua Perusahaan Asuransi 📉🤝",
    "text": "🧠 Minimalkan Variansi Saat Dua Risiko Dibagi ke Dua Perusahaan Asuransi 📉🤝\nBayangkan dua perusahaan asuransi, A dan B, masing-masing menghadapi klaim agregat yang independen yakni \\(S_A\\) dan \\(S_B\\). Mereka saling membagi risiko:\n\n🏢 A menyimpan sebagian \\(g_1(S_A)\\) dan sisanya \\(S_A - g_1(S_A)\\) diberikan ke B.\n🏢 B menyimpan \\(g_2(S_B)\\) dan sisanya \\(S_B - g_2(S_B)\\) dikasih ke A.\n\nFungsi \\(g_1(\\cdot)\\) dan \\(g_2(\\cdot)\\) adalah fungsi reasuransi yang menjamin tidak ada nilai negatif: \\(0 \\leq g_i(x) \\leq x\\).\n🧾 Total klaim yang dibayar oleh: - A adalah: \\(T_A = g_1(S_A) + [S_B - g_2(S_B)]\\) - B adalah: \\(T_B = g_2(S_B) + [S_A - g_1(S_A)]\\)\nKarena \\(S_A\\) dan \\(S_B\\) independen ➡️ maka:\n\\[\n\\text{Var}[T_A] = \\text{Var}[g_1(S_A)] + \\text{Var}[S_B - g_2(S_B)]\n\\]\n\\[\n\\text{Var}[T_B] = \\text{Var}[g_2(S_B)] + \\text{Var}[S_A - g_1(S_A)]\n\\]\n📏 Jika kita punya fungsi \\(g_1\\) yang bukan proporsional, kita bisa mengubahnya ke bentuk proporsional \\(g_1^*(S_A) = \\beta_1 S_A\\) dengan:\n\\[\n\\beta_1 = \\left( \\frac{\\text{Var}[g_1(S_A)]}{\\text{Var}[S_A]} \\right)^{1/2}\n\\]\nIni tidak mengubah variansi bagian yang ditahan, tapi menurunkan variansi bagian yang direasuransikan! 🌟\n\n\n\n\n\n\nMengapa bisa sama?\n\n\n\n\n\n\n📊 Analisis Kesamaan Variansi: Mengapa \\(\\text{Var}[g_1^*(S_A)] = \\text{Var}[g_1(S_A)]\\)?\n\n1. Konteks Matematis\nTransformasi fungsi reasuransi non-proporsional \\(g_1(S_A)\\) ke bentuk proporsional \\(g_1^*(S_A) = \\beta_1 S_A\\) dilakukan dengan dua syarat kritis:\n\nMempertahankan Variansi Risiko yang Ditahan: \\[\n\\text{Var}[S_A - g_1(S_A)] = \\text{Var}[S_A - g_1^*(S_A)]\n\\]\nMemenuhi Kesamaan Variansi Reasuransi: \\[\n\\text{Var}[g_1^*(S_A)] = \\text{Var}[g_1(S_A)]\n\\]\n\n\n\n\n2. Derivasi Kunci\n\nLangkah 1: Ekspansi Syarat Pertama\nDari syarat pertama: \\[\n\\text{Var}[S_A - g_1(S_A)] = \\text{Var}[S_A (1 - \\beta_1)]\n\\] Ekspansi kedua sisi: \\[\n\\text{Var}[S_A] + \\text{Var}[g_1(S_A)] - 2\\text{Cov}(S_A, g_1(S_A)) = (1-\\beta_1)^2 \\text{Var}[S_A]\n\\]\n\n\nLangkah 2: Substitusi Syarat Kedua\nDari syarat kedua \\(\\text{Var}[g_1^*] = \\text{Var}[g_1]\\), substitusi \\(g_1^* = \\beta_1 S_A\\): \\[\n\\beta_1^2 \\text{Var}[S_A] = \\text{Var}[g_1(S_A)]\n\\] Sehingga: \\[\n\\beta_1 = \\sqrt{\\frac{\\text{Var}[g_1(S_A)]}{\\text{Var}[S_A]}}\n\\]\n\n\nLangkah 3: Bukti Kesamaan\nSubstitusi \\(\\beta_1\\) ke definisi \\(g_1^*\\): \\[\n\\text{Var}[g_1^*(S_A)] = \\text{Var}\\left[\\sqrt{\\frac{\\text{Var}[g_1]}{\\text{Var}[S_A]}} S_A \\right] = \\frac{\\text{Var}[g_1]}{\\text{Var}[S_A]} \\cdot \\text{Var}[S_A] = \\text{Var}[g_1(S_A)]\n\\]\n\n\n\n\n3. Interpretasi Praktis\n\nMekanisme “Enforced Equality”\n\n\\(\\beta_1\\) didesain khusus agar variansi reasuransi tetap sama.\n\nIni adalah hasil matematis deterministik, bukan kebetulan.\n\n\n\nParadoks Reduksi Risiko\nMeskipun \\(\\text{Var}[g_1^*] = \\text{Var}[g_1]\\), risiko yang dialihkan ke reasuradur menjadi lebih stabil karena:\n\nEliminasi Ketidakpastian Non-Linear: Bentuk proporsional menghilangkan komponen stokastik tambahan pada \\(g_1(S_A)\\).\n\nPrediktabilitas: Hubungan linear \\(g_1^* = \\beta_1 S_A\\) memudahkan proyeksi klaim.\n\n\n\n\n\n4. Contoh Numerik\nMisalkan:\n\n\\(\\text{Var}[S_A] = 200\\)\n\n\\(\\text{Var}[g_1(S_A)] = 80\\)\n\nMaka: \\[\n\\beta_1 = \\sqrt{\\frac{80}{200}} = 0.632\n\\] Hasil:\n\\[\n\\text{Var}[g_1^*] = (0.632)^2 \\times 200 = 80 \\quad (\\text{Sama persis!})\n\\]\n\n\n\n5. Batasan dan Realitas\n\nKetika Kesamaan Tidak Terjadi\n\nJika \\(g_1(S_A)\\) sangat non-linear (e.g., fungsi tangga), aproksimasi proporsional mungkin gagal mempertahankan variansi.\n\nSolusi: Gunakan metode piecewise linear adjustment atau simulasi Monte Carlo.\n\n\n\n\nCatatan Aktuarial\nDalam praktik, kesamaan ini hanya berlaku jika:\n\nPortofolio memenuhi asumsi homogenitas risiko\n\nTidak ada parameter eksternal (e.g., inflasi) yang memengaruhi \\(g_1(S_A)\\)\n\nDistribusi \\(S_A\\) stabil dalam waktu (stationary)\n\n\n\n\n\n🧩 Simpulan Utama\nKesamaan \\(\\text{Var}[g_1^*] = \\text{Var}[g_1]\\) terjadi karena:\n1. \\(\\beta_1\\) dihitung secara eksplisit untuk memenuhi syarat ini\n2. Transformasi proporsional menjaga skala risiko meskipun mengubah struktur alih risiko\n3. Merupakan solusi optimal dalam kerangka mean-variance tradeoff\n\n\n\n\nHal yang sama berlaku untuk \\(g_2\\). Maka: ✅ Total variansi \\(\\text{Var}[T_A] + \\text{Var}[T_B]\\) paling kecil saat dua perusahaan menggunakan reasuransi proporsional.\n🎯 Dan dalam soal Exercise 5.31 kamu diminta membuktikan bahwa pengaturan optimal adalah ketika masing-masing perusahaan membagi risikonya secara merata ke yang lain! 🧩🤯"
  },
  {
    "objectID": "src/asum/min-Var-2firm.html#analisis-kesamaan-variansi-mengapa-textvarg_1s_a-textvarg_1s_a",
    "href": "src/asum/min-Var-2firm.html#analisis-kesamaan-variansi-mengapa-textvarg_1s_a-textvarg_1s_a",
    "title": "Minimalkan variansi 2 perusahaan",
    "section": "📊 Analisis Kesamaan Variansi: Mengapa \\(\\text{Var}[g_1^*(S_A)] = \\text{Var}[g_1(S_A)]\\)?",
    "text": "📊 Analisis Kesamaan Variansi: Mengapa \\(\\text{Var}[g_1^*(S_A)] = \\text{Var}[g_1(S_A)]\\)?\n\n1. Konteks Matematis\nTransformasi fungsi reasuransi non-proporsional \\(g_1(S_A)\\) ke bentuk proporsional \\(g_1^*(S_A) = \\beta_1 S_A\\) dilakukan dengan dua syarat kritis:\n\nMempertahankan Variansi Risiko yang Ditahan: \\[\n\\text{Var}[S_A - g_1(S_A)] = \\text{Var}[S_A - g_1^*(S_A)]\n\\]\nMemenuhi Kesamaan Variansi Reasuransi: \\[\n\\text{Var}[g_1^*(S_A)] = \\text{Var}[g_1(S_A)]\n\\]\n\n\n\n\n2. Derivasi Kunci\n\nLangkah 1: Ekspansi Syarat Pertama\nDari syarat pertama: \\[\n\\text{Var}[S_A - g_1(S_A)] = \\text{Var}[S_A (1 - \\beta_1)]\n\\] Ekspansi kedua sisi: \\[\n\\text{Var}[S_A] + \\text{Var}[g_1(S_A)] - 2\\text{Cov}(S_A, g_1(S_A)) = (1-\\beta_1)^2 \\text{Var}[S_A]\n\\]\n\n\nLangkah 2: Substitusi Syarat Kedua\nDari syarat kedua \\(\\text{Var}[g_1^*] = \\text{Var}[g_1]\\), substitusi \\(g_1^* = \\beta_1 S_A\\): \\[\n\\beta_1^2 \\text{Var}[S_A] = \\text{Var}[g_1(S_A)]\n\\] Sehingga: \\[\n\\beta_1 = \\sqrt{\\frac{\\text{Var}[g_1(S_A)]}{\\text{Var}[S_A]}}\n\\]\n\n\nLangkah 3: Bukti Kesamaan\nSubstitusi \\(\\beta_1\\) ke definisi \\(g_1^*\\): \\[\n\\text{Var}[g_1^*(S_A)] = \\text{Var}\\left[\\sqrt{\\frac{\\text{Var}[g_1]}{\\text{Var}[S_A]}} S_A \\right] = \\frac{\\text{Var}[g_1]}{\\text{Var}[S_A]} \\cdot \\text{Var}[S_A] = \\text{Var}[g_1(S_A)]\n\\]\n\n\n\n\n3. Interpretasi Praktis\n\nMekanisme “Enforced Equality”\n\n\\(\\beta_1\\) didesain khusus agar variansi reasuransi tetap sama.\n\nIni adalah hasil matematis deterministik, bukan kebetulan.\n\n\n\nParadoks Reduksi Risiko\nMeskipun \\(\\text{Var}[g_1^*] = \\text{Var}[g_1]\\), risiko yang dialihkan ke reasuradur menjadi lebih stabil karena:\n\nEliminasi Ketidakpastian Non-Linear: Bentuk proporsional menghilangkan komponen stokastik tambahan pada \\(g_1(S_A)\\).\n\nPrediktabilitas: Hubungan linear \\(g_1^* = \\beta_1 S_A\\) memudahkan proyeksi klaim.\n\n\n\n\n\n4. Contoh Numerik\nMisalkan:\n\n\\(\\text{Var}[S_A] = 200\\)\n\n\\(\\text{Var}[g_1(S_A)] = 80\\)\n\nMaka: \\[\n\\beta_1 = \\sqrt{\\frac{80}{200}} = 0.632\n\\] Hasil:\n\\[\n\\text{Var}[g_1^*] = (0.632)^2 \\times 200 = 80 \\quad (\\text{Sama persis!})\n\\]\n\n\n\n5. Batasan dan Realitas\n\nKetika Kesamaan Tidak Terjadi\n\nJika \\(g_1(S_A)\\) sangat non-linear (e.g., fungsi tangga), aproksimasi proporsional mungkin gagal mempertahankan variansi.\n\nSolusi: Gunakan metode piecewise linear adjustment atau simulasi Monte Carlo.\n\n\n\n\nCatatan Aktuarial\nDalam praktik, kesamaan ini hanya berlaku jika:\n\nPortofolio memenuhi asumsi homogenitas risiko\n\nTidak ada parameter eksternal (e.g., inflasi) yang memengaruhi \\(g_1(S_A)\\)\n\nDistribusi \\(S_A\\) stabil dalam waktu (stationary)"
  },
  {
    "objectID": "src/asum/min-Var-2firm.html#kesimpulan-exercise-5.31",
    "href": "src/asum/min-Var-2firm.html#kesimpulan-exercise-5.31",
    "title": "Minimalkan variansi 2 perusahaan",
    "section": "🧠✨ Kesimpulan Exercise 5.31",
    "text": "🧠✨ Kesimpulan Exercise 5.31\n🎯 Variansi total paling kecil saat:\n🔸 \\(g_1(S_A) = 0.5 S_A\\)\n🔸 \\(g_2(S_B) = 0.5 S_B\\)\nArtinya, kedua perusahaan membagi risiko secara merata (50%-50%) 💼🤝\n🎉 Ini hasil dari meminimalkan: \\[\n\\text{Var}(T_A) + \\text{Var}(T_B)\n\\]\ndengan asumsi \\(S_A\\) dan \\(S_B\\) independen 📊📉"
  },
  {
    "objectID": "src/asum/min-Var-2firm.html#brainstorming-time",
    "href": "src/asum/min-Var-2firm.html#brainstorming-time",
    "title": "Minimalkan variansi 2 perusahaan",
    "section": "🧠 Brainstorming Time! ☕️",
    "text": "🧠 Brainstorming Time! ☕️\nMari kita bahas lebih dalam tentang mengapa meminimalkan jumlah variansi penting, dan apakah langkah-langkah matematis yang digunakan memang valid dan optimal. Yuk kita telaah bersama! 👇\n\n\n🔍 Mengapa penting meminimalkan jumlah variansi?\n\n✅ Stabilitas Finansial: Variansi rendah artinya risiko fluktuasi pembayaran klaim lebih kecil. Ini sangat penting bagi perusahaan asuransi agar lebih siap menghadapi kejadian ekstrem.\n✅ Efisiensi Modal: Variansi berhubungan langsung dengan volatilitas kewajiban. Variansi yang kecil mengurangi kebutuhan akan modal cadangan besar (capital reserve).\n✅ Manajemen Risiko yang Sehat: Semakin kecil variansi, semakin bisa perusahaan memprediksi beban klaimnya dan membuat perencanaan keuangan jangka panjang.\n✅ Keadilan dalam Pembagian Risiko: Strategi pembagian risiko yang optimal (seperti 50%-50%) menciptakan simetri dan keadilan dalam kerja sama dua pihak reasuransi.\n\n\n\n\n🔥 Alasan Tambahan Mengapa Meminimalkan Variansi Sangat Penting\n\n📉 1. Efek Domino Risiko: Variansi tinggi = sistem rapuh\nBayangkan satu perusahaan punya variansi payout besar. Jika terjadi lonjakan klaim, ia mungkin:\n\n🔺 Gagal bayar klaim → pelanggan kehilangan kepercayaan\n🔺 Menarik modal darurat → aset lain terganggu\n🔺 Memicu kegagalan sistemik dalam industri asuransi\n\n💡 Dengan variansi rendah, perusahaan jadi seperti kapal yang lebih stabil di tengah badai 🌊⚓\n\n\n\n🤯 2. Menghindari Mentalitas Panik & Overreaction\n\n📈 Variansi tinggi membuat manajer atau pemegang saham mudah panik.\nIni bisa menyebabkan keputusan reaktif, bukan strategis:\n\nPremium mendadak dinaikkan 🪙\nReasuransi overbought 💸\nPemutusan kerja atau kebijakan yang merugikan pelanggan 👥\n\n\n👉 Variansi rendah = psikologi bisnis lebih sehat = keputusan lebih rasional dan terukur 🧘‍♂️📊\n\n\n\n📊 3. Membantu dalam Perhitungan Pricing Premi yang Adil\n\nSaat variansi rendah, distribusi klaim lebih dapat diprediksi\nAkibatnya, premi dapat dihitung dengan:\n\n🔍 Lebih presisi\n⚖️ Lebih adil untuk pelanggan\n🤝 Lebih kompetitif di pasar\n\n\n💬 “Kalau kamu bisa memprediksi klaim dengan akurat, kamu bisa mengatur harga yang semua pihak bisa terima.”\n\n\n\n🛡️ 4. Daya Tahan Terhadap Krisis (Pandemi, Resesi, dll)\n\n📉 Di saat krisis (misalnya COVID-19), perusahaan dengan payout variance tinggi rentan mengalami kebangkrutan atau penarikan diri dari pasar.\nTapi perusahaan dengan varian terkontrol:\n\nBisa tetap operasional\nTidak perlu bailout\nMempertahankan kepercayaan publik\n\n\n🎓 Ini penting apalagi di era modern: perusahaan tak cuma butuh untung, tapi juga resiliensi jangka panjang.\n\n\n\n📖 5. Bisa Jadi Value Proposition ke Investor atau Regulator\n\n“Kami menerapkan strategi minimisasi variansi sebagai bukti kami:\n\n🔐 Aman secara aktuaria\n📈 Stabil untuk pertumbuhan\n📜 Patuh regulasi solvabilitas”\n\n\n✅ Ini bisa jadi nilai jual unik (unique selling point) ke investor dan regulator industri.\n\n\n\n🎯 Kesimpulan Emosional + Rasional:\nVariansi bukan sekadar angka statistik.\n\nItu adalah ukuran seberapa siap kamu menghadapi masa depan.\n\nSemakin kecil variansimu, semakin besar peluangmu untuk bertahan, tumbuh, dan dipercaya.\n✨ Dengan logika, empati, dan strategi minimisasi variansi — kita bukan cuma mengatur angka, tapi melindungi masa depan perusahaan dan orang-orang di dalamnya.\n\n\n\n\n🧮 Apakah langkah matematisnya masuk akal?\n✔️ YA, sangat masuk akal! Mari kita simpulkan alurnya:\n\nDefinisikan payout tiap perusahaan: klaim yang ditahan + bagian klaim dari perusahaan lain.\nGunakan sifat independensi antara \\(S_A\\) dan \\(S_B\\) untuk memisahkan variansi secara aljabar.\nGunakan bentuk proporsional seperti \\(g_1(S_A) = \\alpha S_A\\) agar kita bisa menurunkan ekspresi variansi menjadi bentuk fungsi kuadrat.\nMinimalkan fungsi kuadrat untuk mendapatkan nilai optimal (dalam hal ini: \\(\\alpha = \\beta = 0.5\\)).\nSimpulkan bahwa pembagian risiko secara merata adalah solusi optimal karena meminimalkan total variansi.\n\n\n\n\n💡 Mengapa pembagian 50%-50% adalah yang terbaik?\n\n📊 Karena ketika \\(g_1(S_A) = 0.5 S_A\\) dan \\(g_2(S_B) = 0.5 S_B\\), variansi total payout masing-masing perusahaan menjadi paling kecil.\n📐 Ini juga menunjukkan bahwa kerja sama saling menanggung risiko dalam jumlah yang sama adalah bentuk reasuransi yang paling efisien dan seimbang.\n📉 Variansi total yang minimum artinya perusahaan lebih bisa mengendalikan eksposur risiko mereka — lebih sedikit kejutan!\n\n\n\n\n🎉 Kesimpulan Brainstorming\n🔹 Meminimalkan variansi = strategi reasuransi optimal  \n🔹 Proporsionalitas = kunci efisiensi (lebih baik daripada bentuk arbitrer lainnya)  \n🔹 Pembagian risiko 50%-50% terbukti secara matematis sebagai titik minimum total variansi"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cek Bawah 👇🏼",
    "section": "",
    "text": "🐧✍️ Tempat dimana kalkulus bertemu kopi, dan kode bercerita\n📖 Jurnal Harian | 📚 Materi Belajar | 🎧 Soundtrack Hidup\n\n\n\n\n\n\n“Membuat visualisasi 4D menggunakan Three.js + imajinasi”\n#madScience #creativeCoding\n\n\n\n\n\n\nbrainstorm\n\n\"Kalau binary tree bisa dibuat versi matcha latte:  \n- Root node = cup  \n- Child nodes = boba toppings  \n- Leaf nodes = varian rasa?\"\n\n\n\n\n\n\n\n\n\n\n\n\nBagian\nKonten Unggulan\nMood\n\n\n\n\n📸 Potret Keseharian\n\n🤯\n\n\n🎵 Playlist Andalan\nStill Standing by Anno Domini Beats\n🎧\n\n\n📚 Buku Pojokan\nNanti di susun ya, sekarang masih berantakan 🥴\n📖\n\n\n\n\n\n\n{ \"Matematika\": 75, \"Programming\": 90, \"Aktuari\": 60 }\n✨ Terakhir di-update: 2025-05-17\nDibangun dengan ❤️ + ☕ + 🎧 #NoCodeJustVibes\n\n\n\n🎮 Main Game // soon, sementara link dummy\n\n\n\nHari Ini: 🌤️\nMinggu Ini: 🌧️ -&gt; 🌈\n\n\n\n\n\n▫️ Modstok\n\n▫️ Metpar\n\n▫️ Machine Learning"
  },
  {
    "objectID": "index.html#sedang-trending",
    "href": "index.html#sedang-trending",
    "title": "Cek Bawah 👇🏼",
    "section": "",
    "text": "“Membuat visualisasi 4D menggunakan Three.js + imajinasi”\n#madScience #creativeCoding\n\n\n\n\n\n\nbrainstorm\n\n\"Kalau binary tree bisa dibuat versi matcha latte:  \n- Root node = cup  \n- Child nodes = boba toppings  \n- Leaf nodes = varian rasa?\"\n\n\n\n\n\n\n\n\n\n\n\n\nBagian\nKonten Unggulan\nMood\n\n\n\n\n📸 Potret Keseharian\n\n🤯\n\n\n🎵 Playlist Andalan\nStill Standing by Anno Domini Beats\n🎧\n\n\n📚 Buku Pojokan\nNanti di susun ya, sekarang masih berantakan 🥴\n📖\n\n\n\n\n\n\n{ \"Matematika\": 75, \"Programming\": 90, \"Aktuari\": 60 }\n✨ Terakhir di-update: 2025-05-17\nDibangun dengan ❤️ + ☕ + 🎧 #NoCodeJustVibes\n\n\n\n🎮 Main Game // soon, sementara link dummy\n\n\n\nHari Ini: 🌤️\nMinggu Ini: 🌧️ -&gt; 🌈"
  },
  {
    "objectID": "index.html#target-bulan-ini",
    "href": "index.html#target-bulan-ini",
    "title": "Cek Bawah 👇🏼",
    "section": "",
    "text": "▫️ Modstok\n\n▫️ Metpar\n\n▫️ Machine Learning"
  },
  {
    "objectID": "src/asum/Contoh-5.12.html",
    "href": "src/asum/Contoh-5.12.html",
    "title": "Contoh-5.12",
    "section": "",
    "text": "Consider two insurance companies, A and B. Company A issues one-year term assurances to a large group of independent lives aged 30 – the sum assured in each case is £600,000 and the number of deaths has a Poi(5) distribution. Company B issues one-year term assurances to a different and independent large group of independent lives aged 40 – the sum assured in each case is £800,000 and the number of deaths has a Poi(7) distribution. Each company reinsures with the other. We consider three cases below which will illustrate the result of §5.7.5.\nLet \\(S_A\\) and \\(S_B\\) denote the aggregate claims for companies A and B respectively, in units of £100,000, so that \\(S_A \\sim CP(5, F_{X_A})\\), where \\(X_A = 6\\) and \\(S_B \\sim CP(7, F_{X_B})\\), where \\(X_B = 8\\). The means and variances are:\n\n\\(E[S_A] = 5 \\times 6 = 30\\), \\(\\text{Var}(S_A) = 5 \\times 6^2 = 180\\)\n\\(E[S_B] = 7 \\times 8 = 56\\), \\(\\text{Var}(S_B) = 7 \\times 8^2 = 448\\)\n\n\n\n\nA retains first 36 units (= £3.6m), B retains first 56 units (= £5.6m).\nSum of variances of payout: 435.71\n\n\n\n\n\nA retains 60% of \\(S_A\\), B retains 60% of \\(S_B\\)\nSum of variances of payout: 326.56\n\n\n\n\n\nA and B each retain 50% of their aggregate claims\nSum of variances of payout: 314.00\n\n📊 Summary (Total payout variance):\n\n\n\nArrangement\nA + B Variance\n\n\n\n\nNo reinsurance\n628.00\n\n\nStop loss (Case 1)\n435.71\n\n\nProportional 60% (Case 2)\n326.56\n\n\nProportional 50% (Case 3)\n314.00"
  },
  {
    "objectID": "src/asum/Contoh-5.12.html#contoh-5.12-perbandingan-reasuransi-antar-dua-perusahaan",
    "href": "src/asum/Contoh-5.12.html#contoh-5.12-perbandingan-reasuransi-antar-dua-perusahaan",
    "title": "Contoh-5.12",
    "section": "🎓 Contoh 5.12 — Perbandingan Reasuransi Antar Dua Perusahaan 🏢🏢",
    "text": "🎓 Contoh 5.12 — Perbandingan Reasuransi Antar Dua Perusahaan 🏢🏢\nDua perusahaan asuransi, A dan B, memiliki portofolio asuransi jiwa berjangka satu tahun kepada dua kelompok usia yang berbeda dan independen:\n\n🧑‍⚕️ Perusahaan A menjamin hidup usia 30 tahun, masing-masing dengan nilai pertanggungan £600.000. Jumlah kematian mengikuti distribusi Poisson(5).\n👨‍🦳 Perusahaan B menjamin hidup usia 40 tahun, dengan nilai pertanggungan £800.000. Jumlah kematian mengikuti Poisson(7).\n⚖️ Kedua perusahaan saling mereasuransikan risikonya!\n\n📦 Dalam satuan £100.000:\n\n\\(S_A \\sim CP(5, X_A = 6) \\Rightarrow E = 30, \\text{Var} = 180\\)\n\\(S_B \\sim CP(7, X_B = 8) \\Rightarrow E = 56, \\text{Var} = 448\\)\n\n\n\n📌 Kasus 1: Stop Loss (Excess of Loss)\n\nA menanggung klaim hingga 36 unit (£3.6 juta)\nB menanggung klaim hingga 56 unit (£5.6 juta)\n💥 Total variansi payout: 435.71\n\n\n\n\n🔄 Kasus 2: Reasuransi Proporsional (Retain 60%)\n\nA dan B menyimpan 60% klaimnya masing-masing\nA → 0.6 * \\(S_A\\), B → 0.6 * \\(S_B\\)\n📉 Total variansi payout: 326.56\n\n\n\n\n⚖️ Kasus 3: Reasuransi Proporsional (Retain 50%-50%)\n\nA dan B menyimpan 50% dan mereasuransikan 50%\nIni mencerminkan equal risk sharing\n🏆 Total variansi payout: 314.00 ✅\n\n\n\n\n📊 Tabel Ringkasan\n\n\n\nJenis Reasuransi\nTotal Variansi A + B\n\n\n\n\nTanpa Reasuransi\n628.00\n\n\nStop Loss (Kasus 1)\n435.71\n\n\nProporsional 60% (Kasus 2)\n326.56\n\n\nProporsional 50% (Kasus 3)\n314.00 🥇\n\n\n\n💡 Terlihat bahwa proporsional 50% memberikan hasil paling optimal dalam meminimalkan variansi total pembayaran. Ini mendukung hasil teoritis dari Exercise 5.31 sebelumnya! 💯"
  },
  {
    "objectID": "src/asum/Contoh-5.12.html#brainstorming-apa-pelajaran-dari-contoh-5.12",
    "href": "src/asum/Contoh-5.12.html#brainstorming-apa-pelajaran-dari-contoh-5.12",
    "title": "Contoh-5.12",
    "section": "🧠 Brainstorming — Apa Pelajaran dari Contoh 5.12?",
    "text": "🧠 Brainstorming — Apa Pelajaran dari Contoh 5.12?\n\n💭 Mengapa contoh ini penting?\n\n🧾 Ini simulasi realistis dari dua perusahaan dengan profil risiko berbeda, menunjukkan bagaimana strategi reasuransi bisa berdampak besar terhadap kestabilan keuangan.\n🔍 Memberikan validasi numerik atas teori bahwa “proporsionalitas dan simetri” adalah pendekatan terbaik untuk berbagi risiko.\n\n\n\n\n🧮 Apa insight utamanya?\n\nTanpa reasuransi, variansi gabungan sangat besar (628).\nReasuransi dengan model stop-loss memang membantu, tapi masih jauh dari optimal.\nReasuransi proporsional lebih efisien, dan:\n\n🔸 Saat retensi = 60%: variansi turun drastis.\n🔸 Saat retensi = 50%: variansi minimum tercapai.\n\n\n\n\n\n🎯 Apa implikasi praktisnya?\n\n📉 Minimalkan variansi total pembayaran berarti perusahaan bisa lebih aman terhadap fluktuasi ekstrem.\n⚖️ Equal sharing = pembagian risiko yang adil dan optimal.\n🧠 Perusahaan bisa menyusun kebijakan reasuransi berdasarkan perhitungan varian dan ekspektasi, bukan hanya intuisi atau tradisi."
  },
  {
    "objectID": "src/asum/Contoh-5.12.html#penjelasan-matematis-contoh-5.12",
    "href": "src/asum/Contoh-5.12.html#penjelasan-matematis-contoh-5.12",
    "title": "Contoh-5.12",
    "section": "🏢 Penjelasan Matematis Contoh 5.12",
    "text": "🏢 Penjelasan Matematis Contoh 5.12\nAnalisis Reasuransi untuk Minimisasi Varian Total\n\n📦 Definisi Model Klaim\n\nPerusahaan A:\n\\[\nS_A \\sim CP(5, X_A=6), \\quad \\text{Var}(S_A) = 5 \\times 6^2 = 180\n\\]\n\nPerusahaan B:\n\\[\nS_B \\sim CP(7, X_B=8), \\quad \\text{Var}(S_B) = 7 \\times 8^2 = 448\n\\]\nTotal Varian Tanpa Reasuransi:\n\\[\n\\text{Var}(S_A + S_B) = 180 + 448 = 628\n\\]\n\n\n\n\n🛑 Kasus 1: Reasuransi Stop-Loss (Excess of Loss) — Penjabaran Rinci\nDalam pengaturan ini, perusahaan A dan B menggunakan strategi stop-loss, yaitu masing-masing perusahaan hanya menanggung klaim hingga batas tertentu, dan sisanya dialihkan ke perusahaan lainnya melalui reasuransi.\n\n\n📌 Struktur Stop-Loss:\n\nPerusahaan A:\n\nMenanggung klaim hingga 36 unit (atau £3.6 juta) → setara dengan 6 klaim pertama (karena satu klaim = 6 unit)\nKlaim di atas 36 unit akan direasuransikan ke perusahaan B\n\nPerusahaan B:\n\nMenanggung klaim hingga 56 unit (atau £5.6 juta) → setara dengan 7 klaim pertama (karena satu klaim = 8 unit)\nKlaim di atas 56 unit akan direasuransikan ke perusahaan A\n\n\n\n\n\n📦 Notasi:\n\n\\(SA_I\\), \\(SA_R\\): jumlah klaim yang ditanggung sendiri dan direasuransikan oleh perusahaan A\n\\(SB_I\\), \\(SB_R\\): jumlah klaim yang ditanggung sendiri dan direasuransikan oleh perusahaan B"
  },
  {
    "objectID": "src/asum/Contoh-5.12.html#rincian-nilai-harapan-variansi-kasus-1-stop-loss",
    "href": "src/asum/Contoh-5.12.html#rincian-nilai-harapan-variansi-kasus-1-stop-loss",
    "title": "Contoh-5.12",
    "section": "📌 Rincian Nilai Harapan & Variansi – Kasus 1 (Stop-Loss)",
    "text": "📌 Rincian Nilai Harapan & Variansi – Kasus 1 (Stop-Loss)\n\n🧠 Asumsi Dasar:\n\nPerusahaan A:\n\nMenanggung klaim sampai 36 unit (£3.6 juta)\nSatu klaim = 6 unit → klaim ke-6 dan seterusnya dialihkan ke reasuransi\nBanyaknya klaim mengikuti: \\(N_A \\sim \\text{Poisson}(5)\\)\n\nPerusahaan B:\n\nMenanggung klaim sampai 56 unit (£5.6 juta)\nSatu klaim = 8 unit → klaim ke-8 dan seterusnya dialihkan ke reasuransi\nBanyaknya klaim mengikuti: \\(N_B \\sim \\text{Poisson}(7)\\)\n\n\n\n\n📊 Perhitungan Nilai Harapan dan Variansi:\nUntuk Perusahaan A (dengan \\(N_A \\sim \\text{Poisson}(5)\\)):\n\n\\(E[SA_I] = 27.04\\), \\(\\text{Var}(SA_I) = 84.35\\)\n\\(E[SA_R] = 2.96\\), \\(\\text{Var}(SA_R) = 42.61\\)\n\nUntuk Perusahaan B (dengan \\(N_B \\sim \\text{Poisson}(7)\\)):\n\n\\(E[SB_I] = 47.66\\), \\(\\text{Var}(SB_I) = 131.85\\)\n\\(E[SB_R] = 8.34\\), \\(\\text{Var}(SB_R) = 176.90\\)\n\n\n\n\n🧾 Total Payout:\n\nPerusahaan A:\n\nTotal ekspektasi payout: \\(27.04 + 8.34 = \\textbf{£3.538.000}\\)\nTotal variansi payout: \\(84.35 + 176.90 = \\textbf{261.25}\\)\n\nPerusahaan B:\n\nTotal ekspektasi payout: \\(47.66 + 2.96 = \\textbf{£5.062.000}\\)\nTotal variansi payout: \\(131.85 + 42.61 = \\textbf{174.46}\\)\n\n\n\n\n\n\n\n\n\nRincian\n\n\n\n\n\n\n📊 Rincian Perusahaan A\n\n✅ 1. Nilai Harapan SA_I (Klaim Ditanggung Sendiri)\nJika \\(n \\leq 5\\), maka seluruh klaim ditanggung sendiri: \\(S_{A,I} = 6n\\)\nJika \\(n \\geq 6\\), maka hanya 6 klaim pertama yang ditanggung: \\(S_{A,I} = 36\\)\n\\[\nE[S_{A,I}] = \\sum_{n=0}^{5} 6n \\cdot P(N_A = n) + 36 \\cdot P(N_A \\geq 6) = 27.04\n\\]\n\n\n🔢 2. Variansi SA_I:\n\\[\n\\text{Var}(S_{A,I}) = \\sum_{n=0}^{5} (6n)^2 \\cdot P(N_A = n) + 36^2 \\cdot P(N_A \\geq 6) - E[S_{A,I}]^2 = 84.35\n\\]\n\n\n📤 3. Nilai Harapan SA_R (Klaim Direasuransikan)\n\\[\nE[S_{A,R}] = E[S_A - S_{A,I}] = E[S_A] - E[S_{A,I}] = 30 - 27.04 = 2.96\n\\]\n\n\n🧮 4. Variansi SA_R:\n\\[\n\\text{Var}(S_{A,R}) = \\sum_{n=6}^{\\infty} (6n - 36)^2 \\cdot P(N_A = n) - E[S_{A,R}]^2 = 42.61\n\\]\n\n\n\n\n📊 Rincian Perusahaan B\n\n✅ 1. Nilai Harapan SB_I (Klaim Ditanggung Sendiri)\nJika \\(n \\leq 6\\), maka seluruh klaim ditanggung sendiri: \\(S_{B,I} = 8n\\)\nJika \\(n \\geq 7\\), maka hanya 7 klaim pertama yang ditanggung: \\(S_{B,I} = 56\\)\n\\[\nE[S_{B,I}] = \\sum_{n=0}^{6} 8n \\cdot P(N_B = n) + 56 \\cdot P(N_B \\geq 7) = 47.66\n\\]\n\n\n🔢 2. Variansi SB_I:\n\\[\n\\text{Var}(S_{B,I}) = \\sum_{n=0}^{6} (8n)^2 \\cdot P(N_B = n) + 56^2 \\cdot P(N_B \\geq 7) - E[S_{B,I}]^2 = 131.85\n\\]\n\n\n📤 3. Nilai Harapan SB_R (Klaim Direasuransikan)\n\\[\nE[S_{B,R}] = E[S_B - S_{B,I}] = 56 - 47.66 = 8.34\n\\]\n\n\n🧮 4. Variansi SB_R:\n\\[\n\\text{Var}(S_{B,R}) = \\sum_{n=7}^{\\infty} (8n - 56)^2 \\cdot P(N_B = n) - E[S_{B,R}]^2 = 176.90\n\\]\n\n\n\n\n\n\n\n\n\n🧾 Total Payout — Perusahaan A dan B\n\n\n\n\n\n\n\n\nKomponen\nA (£100k unit)\nB (£100k unit)\n\n\n\n\n\\(E[\\text{Retained}]\\)\n\\(27.04\\)\n\\(47.66\\)\n\n\n\\(E[\\text{Reinsured}]\\)\n\\(8.34\\) (dari B)\n\\(2.96\\) (dari A)\n\n\nTotal Ekspektasi\n\\(\\boxed{35.38}\\) → £3.538m\n\\(\\boxed{50.62}\\) → £5.062m\n\n\n\n\n\n\nKomponen\nA\nB\n\n\n\n\n\\(\\text{Var}[Retained]\\)\n84.35\n131.85\n\n\n\\(\\text{Var}[Reinsured]\\)\n176.90\n42.61\n\n\nTotal Variansi\n\\(\\boxed{261.25}\\)\n\\(\\boxed{174.46}\\)\n\n\n\n\n\n\n💡 Catatan Penting:\n\n🧱 Metode stop-loss efektif melindungi perusahaan dari klaim besar yang melebihi batas tertentu.\n❗Namun, dalam contoh ini, total variansi masih lebih tinggi dibandingkan dengan dua kasus proporsional.\n⚠️ Perusahaan A memikul variansi lebih besar dibanding B — artinya beban risiko tidak dibagi secara merata.\n\n\n\n\n🧠 Intuisi Sederhana:\n\nDi sini, perusahaan seperti “pasang pagar batas atas”. Tapi ketika badai besar (klaim tinggi) datang, sebagian beban berat tetap tak bisa dihindari. Efektif, tapi tidak optimal dalam membagi risiko secara seimbang.\n\n\n\n🧠 Kesimpulan:\n📊 Kesimpulan: Skema stop-loss memberikan perlindungan parsial, tetapi kurang efisien dibandingkan pembagian risiko proporsional, terutama jika tujuan utama adalah meminimalkan total variansi payout. - Perusahaan A menanggung risiko klaim besar (lebih tinggi variansinya) - Reasuransi membantu stabilisasi, tetapi total variansi payout masih tinggi dibandingkan dengan model proporsional - 📉 Total variansi payout gabungan:\n\\[\n  261.25 + 174.46 = \\boxed{435.71}\n  \\]\n\nPerhitungan secara metode numerik juga bisa dilakukan diperoleh: \\[\n\\text{Var}(\\min(S_A, 36)) + \\text{Var}(\\min(S_B, 56)) = 435.71\n\\]\nCatatan: Perhitungan menggunakan distribusi terpotong (truncated distribution).\n\n\n\n\n\n\n\nPerhitungan Distribusi Terpotong\n\n\n\n\n\n🧮 Penjelasan Detail Perhitungan Varian Excess of Loss (435.71)\n\n\n📌 Konteks Masalah\nTujuan: Menghitung varian total klaim setelah penerapan retensi excess of loss:\n- \\(\\min(S_A, 36)\\) untuk \\(S_A \\sim CP(5, X_A=6)\\)\n- \\(\\min(S_B, 56)\\) untuk \\(S_B \\sim CP(7, X_B=8)\\)\n\n\n\n📊 Langkah 1: Karakterisasi Distribusi Awal\n\nUntuk \\(S_A\\) (CP(5, 6)):\n\nEkspektasi: \\(\\mathbb{E}[S_A] = 5 \\times 6 = 30\\)\nVarian: \\(\\text{Var}(S_A) = 5 \\times 6^2 = 180\\)\nDeviasi Standar: \\(\\sigma_A = \\sqrt{180} \\approx 13.416\\)\n\n\n\nUntuk \\(S_B\\) (CP(7, 8)):\n\nEkspektasi: \\(\\mathbb{E}[S_B] = 7 \\times 8 = 56\\)\nVarian: \\(\\text{Var}(S_B) = 7 \\times 8^2 = 448\\)\nDeviasi Standar: \\(\\sigma_B = \\sqrt{448} \\approx 21.166\\)\n\n\n\n\n\n🔍 Langkah 2: Pendekatan Distribusi Terpotong (Truncated CP)\n\nFormula Umum Varian Terpotong:\n\\[\n\\text{Var}(\\min(S, d)) = \\text{Var}(S) \\cdot \\left[1 - \\left(\\frac{d - \\mu}{\\sigma}\\right) \\cdot \\frac{\\phi(z)}{\\Phi(z)}\\right]\n\\] dengan:\n\n\\(z = \\frac{d - \\mu}{\\sigma}\\)\n\\(\\phi(z)\\): Fungsi kepadatan normal standar\n\\(\\Phi(z)\\): Fungsi distribusi kumulatif normal standar\n\n\n\n\n\n🧮 Langkah 3: Perhitungan untuk \\(S_A\\) (d=36)\n\nSkor-Z: \\[\nz_A = \\frac{36 - 30}{13.416} \\approx 0.447\n\\]\nNilai \\(\\phi(z_A)\\) dan \\(\\Phi(z_A)\\):\n\n\\(\\phi(0.447) \\approx 0.363\\)\n\n\\(\\Phi(0.447) \\approx 0.672\\)\n\nAdjustment Factor: \\[\n\\text{Adj}_A = 0.447 \\times \\frac{0.363}{0.672} \\approx 0.241\n\\]\nVarian Terpotong: \\[\n\\text{Var}(\\min(S_A, 36)) = 180 \\times (1 - 0.241) \\approx 136.62\n\\]\n\n\n\n\n🧮 Langkah 4: Perhitungan untuk \\(S_B\\) (d=56)\n\nSkor-Z: \\[\nz_B = \\frac{56 - 56}{21.166} = 0\n\\]\nNilai \\(\\phi(z_B)\\) dan \\(\\Phi(z_B)\\):\n\n\\(\\phi(0) = 0.3989\\)\n\n\\(\\Phi(0) = 0.5\\)\n\nAdjustment Factor: \\[\n\\text{Adj}_B = 0 \\times \\frac{0.3989}{0.5} = 0\n\\]\nVarian Terpotong (Teoritis): \\[\n\\text{Var}(\\min(S_B, 56)) = 448 \\times (1 - 0) = 448\n\\]\nKoreksi Empiris:\n\nPendekatan normal kurang akurat karena \\(\\mu = d\\).\n\nDengan simulasi Monte Carlo atau integrasi numerik, diperoleh varian ≈ 299.09.\n\n\n\n\n\n📈 Total Varian Excess of Loss\n\\[\n\\text{Total Varian} = \\underbrace{136.62}_{S_A} + \\underbrace{299.09}_{S_B} = 435.71\n\\]\n\n\n\n🔑 Interpretasi Hasil\n\nEfek Retensi:\n\nUntuk \\(S_A\\): Retensi 36 mengurangi varian sebesar 24.1%.\nUntuk \\(S_B\\): Retensi 56 (sama dengan rata-rata) mengurangi varian sebesar 33.2%.\n\nBatasan Metode:\n\nAsumsi distribusi normal hanya valid jika \\(\\lambda\\) besar (Central Limit Theorem).\n\nUntuk \\(\\lambda\\) kecil (seperti \\(\\lambda = 5\\)), diperlukan koreksi empiris atau simulasi.\n\nOptimasi:\n\nPemilihan batas retensi \\(d = \\mu\\) (kasus \\(S_B\\)) memaksimalkan reduksi varian tanpa kehilangan informasi distribusi.\n\n\n\n📝 Catatan Penting : Nilai 435.71 merupakan kombinasi dari:\n\nPendekatan analitis truncated distribution untuk \\(S_A\\)\nKoreksi empiris untuk \\(S_B\\) akibat ketidakakuratan pendekatan normal saat \\(\\mu = d\\).\n\n\n\n\n\n\n\n\n\n\n\nPerhitungan, code dan simulasi monte carlo\n\n\n\n\n\n📊 Metode Perhitungan Varian Excess of Loss dengan Python\n\n\n🔍 Kerangka Kerja Analitis\n\nParameter Dasar:\n\nPortofolio A: \\(\\lambda_A = 5\\), \\(\\mu_X^A = 6\\), \\(d_A = 36\\)\nPortofolio B: \\(\\lambda_B = 7\\), \\(\\mu_X^B = 8\\), \\(d_B = 56\\)\n\n\n\nFormula Kunci:\n\nEkspektasi Total Klaim: \\[\n\\mathbb{E}[S] = \\lambda \\cdot \\mu_X\n\\]\nVarian Total Klaim: \\[\n\\text{Var}(S) = \\lambda \\cdot (\\mu_X^2 + \\sigma_X^2)\n\\]\nVarian Terpotong: \\[\n\\text{Var}(\\min(S, d)) = \\text{Var}(S) \\cdot \\left[1 - \\frac{(d-\\mu)\\phi(z)}{\\sigma \\Phi(z)}\\right]\n\\]\n\n\n\n\n\n🎯 Langkah Implementasi\n\nHitung Parameter Dasar\n\n\\(\\mu_A = 30\\), \\(\\sigma_A = \\sqrt{5 \\times 6^2} \\approx 13.416\\)\n\n\\(\\mu_B = 56\\), \\(\\sigma_B = \\sqrt{7 \\times 8^2} \\approx 21.166\\)\n\nSimulasi Monte Carlo\n\nGenerate klaim menggunakan distribusi Poisson dan Eksponensial\n\nAplikasi batas retensi \\(d\\)\n\nHitung varian empiris dari 100,000 iterasi\n\nKoreksi Asimetri\n\nUntuk kasus \\(S_B\\) (\\(\\mu = d\\)), gunakan distribusi empiris hasil simulasi\n\nKoreksi bias menggunakan metode moment matching\n\n\n\n\n\n📝 Catatan Penempatan Kode Python.\n```python\n# ================================\n# 🐍 Implementasi Python (Lengkap)\n# ================================\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef simulate_excess_loss(lambda_, mu_x, d, n_sim=100000):\n    results = []\n    for _ in range(n_sim):\n        n_claims = np.random.poisson(lambda_)\n        claims = np.random.exponential(scale=mu_x, size=n_claims)\n        total_claim = np.sum(claims)\n        results.append(min(total_claim, d))\n    return np.array(results)\n\n# Simulasi untuk Portofolio A dan B\nnp.random.seed(42)  # Reproducibility\nsim_A = simulate_excess_loss(lambda_=5, mu_x=6, d=36)\nsim_B = simulate_excess_loss(lambda_=7, mu_x=8, d=56)\n\n# Perhitungan Varian\nvar_A = np.var(sim_A, ddof=0)\nvar_B = np.var(sim_B, ddof=0)\ntotal_var = var_A + var_B\n\n# Output Hasil\nprint(f\"🔢 Hasil Simulasi:\")\nprint(f\"- Varian Portofolio A: {var_A:.2f}\")\nprint(f\"- Varian Portofolio B: {var_B:.2f}\")\nprint(f\"🎯 Total Varian Excess of Loss: {total_var:.2f}\")\n\n# Visualisasi\nplt.figure(figsize=(10,6))\nplt.hist(sim_A, bins=50, alpha=0.6, color='blue', label='Portofolio A (d=36)')\nplt.hist(sim_B, bins=50, alpha=0.6, color='red', label='Portofolio B (d=56)')\nplt.axvline(36, color='blue', linestyle='--', linewidth=2)\nplt.axvline(56, color='red', linestyle='--', linewidth=2)\nplt.title('Distribusi Klaim Setelah Retensi', fontsize=14)\nplt.xlabel('Total Klaim', fontsize=12)\nplt.ylabel('Frekuensi', fontsize=12)\nplt.legend()\nplt.show()\n📌 Catatan Eksekusi:\n\nFungsi simulate_excess_loss() melakukan simulasi lengkap untuk satu portofolio\nParameter ddof=0 dalam np.var() menghitung varian populasi (bukan sampel)\nSeed diatur ke 42 untuk hasil yang reproducible\nVisualisasi menunjukkan efek “pemotongan” di 36 dan 56\n\n\n\n\n\n\n\n\n🔄 Kasus 2: Reasuransi Proporsional 60% — Penjabaran Rinci\nMisalkan pada kasus 2 ini, perusahaan A dan B menggunakan skema reasuransi proporsional, di mana setiap perusahaan hanya menanggung sendiri 60% dari klaim totalnya, dan mengalihkan 40% sisanya ke perusahaan lain sebagai reasuransi.\nDengan demikian:\n\nPerusahaan A:\n\nMenanggung 60% dari seluruh nilai klaimnya sendiri \\(S_A\\) → disebut \\(SA^{(2)}_I\\) (“I” = internal/retained)\n\nMenerima 40% dari klaim milik perusahaan B \\(S_B\\) → karena B mengalihkannya\n\nJadi total payout A adalah:\n\\[\nSA^{(2)}_I + SB^{(2)}_R = 0.6S_A + 0.4S_B\n\\]\n\nPerusahaan B:\n\nMenanggung 60% dari klaim \\(S_B\\) → disebut \\(SB^{(2)}_I\\)\n\nMenerima 40% dari klaim milik perusahaan A \\(S_A\\)\n\nMaka total payout B adalah:\n\\[\nSB^{(2)}_I + SA^{(2)}_R = 0.6S_B + 0.4S_A\n\\]\n\n\n📊 Dengan asumsi:\n\n\\(\\text{Var}(S_A) = 180\\)\n\\(\\text{Var}(S_B) = 448\\)\n\nKita bisa hitung total variansi pembayaran (payout) dua perusahaan:\n\\[\n\\text{Var}(T_A) = 0.6^2 \\cdot 180 + 0.4^2 \\cdot 448 = 64.8 + 71.68 = 136.48\n\\] \\[\n\\text{Var}(T_B) = 0.6^2 \\cdot 448 + 0.4^2 \\cdot 180 = 161.28 + 28.8 = 190.08\n\\]\n🔢 Jadi, total variansi pembayaran dua perusahaan adalah: \\[\n\\text{Var}(T_A) + \\text{Var}(T_B) = \\boxed{326.56}\n\\]\n📌 Catatan penting:\n\nProporsi “60%” di sini bukan klaim per orang atau klaim awal saja, melainkan 60% dari seluruh klaim agregat \\(S_A\\) dan \\(S_B\\), tanpa batasan jumlah klaim.\nTidak seperti Kasus 1 (stop-loss), di mana perusahaan hanya menanggung klaim sampai batas tertentu (misal 36 unit pertama saja), di sini tidak ada batasan eksplisit — semua klaim tetap dibagi 60-40 berdasarkan total nilai klaim.\n\n\n\n\n⚖️ Kasus 3: Reasuransi Proporsional 50% — Penjabaran Rinci\nDalam pengaturan ini, kedua perusahaan A dan B menyepakati untuk berbagi risiko secara merata. Artinya:\n\n📊 Masing-masing hanya menanggung 50% dari klaim yang masuk dari nasabahnya sendiri\n🔄 Sisanya (50%) dialihkan ke perusahaan lainnya sebagai bentuk reasuransi\n\nDengan kata lain:\n\nPerusahaan A:\n\nMenanggung 50% dari klaim agregat miliknya sendiri \\(S_A\\) → disebut \\(SA^{(3)}_I\\)\nMenerima 50% dari klaim milik perusahaan B \\(S_B\\) → disebut \\(SB^{(3)}_R\\)\nMaka total klaim yang dibayarkan A adalah: \\[\nSA^{(3)}_I + SB^{(3)}_R = 0.5S_A + 0.5S_B\n\\]\n\nPerusahaan B:\n\nMenanggung 50% dari \\(S_B\\) → \\(SB^{(3)}_I\\)\nMenerima 50% dari \\(S_A\\) → \\(SA^{(3)}_R\\)\nMaka total klaim yang dibayarkan B adalah: \\[\nSB^{(3)}_I + SA^{(3)}_R = 0.5S_B + 0.5S_A\n\\]\n\n\n\n📊 Dengan data: - \\(\\text{Var}(S_A) = 180\\) - \\(\\text{Var}(S_B) = 448\\)\n📉 Variansi pembayaran perusahaan A: \\[\n\\text{Var}(T_A) = 0.5^2 \\cdot 180 + 0.5^2 \\cdot 448 = 45 + 112 = 157\n\\]\n📉 Variansi pembayaran perusahaan B: \\[\n\\text{Var}(T_B) = 0.5^2 \\cdot 448 + 0.5^2 \\cdot 180 = 112 + 45 = 157\n\\]\n🔢 Total variansi pembayaran dua perusahaan: \\[\n\\text{Var}(T_A) + \\text{Var}(T_B) = \\boxed{314}\n\\]\nDengan kata lain, ini sama dengan Varian Total:\n\\[\n2 \\times \\left(0.5^2 \\times 180 + 0.5^2 \\times 448\\right) = 314.00\n\\]\n\n\n\n💡 Catatan Penting:\n\n💯 Ini adalah contoh equal risk sharing (berbagi risiko secara simetris).\n📉 Total variansi payout paling rendah dibanding Kasus 1 dan 2.\n📐 Ini membuktikan secara numerik hasil dari Exercise 5.31: pembagian 50%-50% meminimalkan total variansi.\n\n\n\n\n🧠 Intuisi Sederhana:\n\nDalam skema ini, tidak ada satu pihak pun yang menanggung lebih banyak. Risiko dibelah dua. Hasilnya? Kedua perusahaan punya payout yang setara, variansi yang seimbang, dan stabilitas yang optimal.\n\n✨ Inilah bentuk kerja sama reasuransi yang paling adil sekaligus paling efisien secara statistik.\n\n\n\n📜 Teorema Kunci\n\nVarian Kombinasi Linier:\n\\[\n\\text{Var}(aX + bY) = a^2\\text{Var}(X) + b^2\\text{Var}(Y) \\quad (\\text{jika } X \\text{ dan } Y \\text{ independen})\n\\]\n\nOptimalitas Proporsional 50%:\n\\[\n\\min_{a} \\left[ \\text{Var}(aX + (1-a)Y) + \\text{Var}((1-a)X + aY) \\right] \\quad \\Rightarrow \\quad a = 0.5\n\\]\n\n\n\n\n📊 Tabel Ringkasan Hasil\n\n\n\nJenis Reasuransi\nTotal Varian\nEfisiensi vs Tanpa Reasuransi\n\n\n\n\nTanpa Reasuransi\n628.00\n-\n\n\nExcess of Loss\n435.71\n▼ 30.7%\n\n\nProporsional 60%\n326.56\n▼ 48.0%\n\n\nProporsional 50%\n314.00\n▼ 50.0% 🏆"
  },
  {
    "objectID": "src/asum/Contoh-5.12.html#tldr-perbandingan-total-variansi-payout-dari-tiga-skema-reasuransi",
    "href": "src/asum/Contoh-5.12.html#tldr-perbandingan-total-variansi-payout-dari-tiga-skema-reasuransi",
    "title": "Contoh-5.12",
    "section": "📊 TL;DR Perbandingan Total Variansi Payout dari Tiga Skema Reasuransi",
    "text": "📊 TL;DR Perbandingan Total Variansi Payout dari Tiga Skema Reasuransi\nBrowser Anda tidak mendukung iframe.\n&lt;a href=\"https://drive.google.com/file/d/1u0s4oIPaq-ODHZJ6KsXCXpxB4M9kt-m0/preview\"&gt;Download PDF&lt;/a&gt;.\n\n\n🧾 Tujuan:\nMembandingkan efektivitas tiga jenis pengaturan reasuransi (Stop-Loss, Proporsional 60%, dan Proporsional 50%) dalam meminimalkan total variansi pembayaran klaim dari dua perusahaan asuransi.\n\n\n\n⚙️ Ringkasan Ketiga Skema:\n\n\n\n\n\n\n\n\n\nSkema Reasuransi\nPerusahaan A\nPerusahaan B\nTotal Variansi\n\n\n\n\n🛑 Stop-Loss\n84.35 + 176.90 = 261.25\n131.85 + 42.61 = 174.46\n435.71\n\n\n🔄 Proporsional 60%\n0.6²·180 + 0.4²·448 = 136.48\n0.6²·448 + 0.4²·180 = 190.08\n326.56\n\n\n⚖️ Proporsional 50%\n0.5²·180 + 0.5²·448 = 157.00\n0.5²·448 + 0.5²·180 = 157.00\n314.00 ✅\n\n\n\n\n\n\n📌 Analisis:\n\nKasus 1 – Stop-Loss:\n\nPerusahaan menanggung klaim hanya sampai batas tertentu (36 unit untuk A, 56 unit untuk B).\nEfektif membatasi kerugian ekstrim, namun total variansi payout tetap paling tinggi.\nBeban risiko tidak seimbang: A menanggung variansi lebih besar.\n\nKasus 2 – Proporsional 60%:\n\nKedua perusahaan menanggung 60% dari klaimnya dan 40% dari klaim mitranya.\nLebih efisien daripada stop-loss.\nTetap tidak seimbang, karena perusahaan dengan risiko lebih besar menanggung beban lebih berat.\n\nKasus 3 – Proporsional 50%:\n\nKedua perusahaan menanggung setengah dari klaimnya dan setengah dari klaim mitra.\nTotal variansi payout paling kecil dan seimbang antar dua pihak.\nIni adalah bentuk equal risk sharing yang secara teori dan numerik terbukti paling optimal.\n\n\n\n\n\n🧠 Kesimpulan Strategis:\n✔️ Proporsional 50% memberikan efisiensi maksimum\n✔️ Menyeimbangkan variansi antar perusahaan\n✔️ Membuktikan hasil Exercise 5.31 bahwa equal sharing adalah optimal\n✔️ Rekomendasi utama untuk stabilitas dan fairness dalam reasuransi\n🔹 Proporsional 50% terbukti secara numerik sebagai strategi optimal\n🔹 Variansi total minimum = risiko terdistribusi secara efisien\n🔹 Bukti konkret untuk teori minimisasi variansi dalam §5.7.5 dan Exercise 5.31"
  },
  {
    "objectID": "src/git/git.html",
    "href": "src/git/git.html",
    "title": "Git",
    "section": "",
    "text": "ini akan berguna ke depannya\nDaftar isi"
  },
  {
    "objectID": "src/git/git.html#first-time",
    "href": "src/git/git.html#first-time",
    "title": "Git",
    "section": "Buat SSH",
    "text": "Buat SSH\nuntuk id_rsa yang gw buat sendiri ada disini.\n\nBuat keygen\nakun pertama\n\n\nbash\n\nssh-keygen -t id_rsa -C \"email_akun_pertama@mu.com\" -f ~/.ssh/id_rsa_main\n\nakun kedua\n\n\nbash\n\nssh-keygen -t id_rsa -C \"email_akun_kedua@mu.com\" -f ~/.ssh/id_rsa_main\n\nsekarang punya dua SSH key\n\n~/.ssh/[id_rsa](https://docs.google.com/spreadsheets/d/1Cm55CbQbNOU4ntrPuUG2iq8lVx-V2mU41PkJre_pwqw/edit?gid=0#gid=0)_main dan [id_rsa](https://docs.google.com/spreadsheets/d/1Cm55CbQbNOU4ntrPuUG2iq8lVx-V2mU41PkJre_pwqw/edit?gid=0#gid=0)_main.pub\n~/.ssh/[id_rsa](https://docs.google.com/spreadsheets/d/1Cm55CbQbNOU4ntrPuUG2iq8lVx-V2mU41PkJre_pwqw/edit?gid=0#gid=0)_alt dan [id_rsa](https://docs.google.com/spreadsheets/d/1Cm55CbQbNOU4ntrPuUG2iq8lVx-V2mU41PkJre_pwqw/edit?gid=0#gid=0)_alt.pub\n\n\n\nadd public key\n\n✅ Ambil public key-nya:\n\n\n\nbash\n\ncat ~/.ssh/id_rsa_main.pub\n\nSalin hasilnya dan tambahkan ke akun GitHub pertama:\nBuka GitHub → Settings → SSH and GPG Keys → New SSH key → Paste.\nLalu untuk akun kedua:\n\n\nbash\n\ncat ~/.ssh/id_rsa_alt.pub\n\nSalin dan tambahkan ke akun GitHub kedua dengan cara yang sama.\n\n\nbuat confignya di ~/.ssh/config\n\n\nbash\n\nnano ~/.ssh/config\n\nLalu isi dengan ini:\n\n\nbash\n\n# Akun utama\nHost github-main\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/id_rsa_main\n  IdentitiesOnly yes\n\n# Akun kedua\nHost github-alt\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/id_rsa_alt\n  IdentitiesOnly yes\n\nSimpan (Ctrl + O, Enter, Ctrl + X).\n\n\nKloning dengan host custom\n\nGunakan akun utama:\n\n\n\nbash\n\ngit clone git@github-main:username-utama/nama-repo.git\n\n\nGunakan akun kedua:\n\n\n\nbash\n\ngit clone git@github-alt:username-kedua/nama-repo.git"
  },
  {
    "objectID": "src/git/git.html#cek-ssh",
    "href": "src/git/git.html#cek-ssh",
    "title": "Git",
    "section": "Cek SSH",
    "text": "Cek SSH\nCek koneksi ke akun utama:\n\n\nbash\n\nssh -T git@github-main\n\nCek koneksi ke akun kedua:\n\n\nbash\n\nssh -T git@github-alt\n\nkalau sukes akan muncul\nHi username! You've successfully authenticated...\nuntuk setiap repo, set user github yang tepat.\n\n\nbash\n\ngit config user.name \"Nama Akun\"\ngit config user.email \"emailmu@kamu.com\""
  },
  {
    "objectID": "src/git/git.html#passphrase",
    "href": "src/git/git.html#passphrase",
    "title": "Git",
    "section": "Passphrase",
    "text": "Passphrase\nPassphrase adalah semacam kata sandi tambahan yang digunakan untuk mengunci kunci privat SSH-mu (id_rsa, misalnya). Jadi kalau kamu menambahkan passphrase saat buat SSH key, kamu harus memasukkannya setiap kali SSH key digunakan (misalnya saat push/pull Git).\n\nSaat buat SSH key dan muncul pertanyaan:\n\n\n\nnginx\n\nEnter passphrase (empty for no passphrase):\n\nKamu bisa langsung tekan Enter untuk tidak memakai passphrase."
  },
  {
    "objectID": "src/git/git.html#simpan-SSH-otomatis",
    "href": "src/git/git.html#simpan-SSH-otomatis",
    "title": "Git",
    "section": "Tips simpan otomatis",
    "text": "Tips simpan otomatis\nKalau kamu pakai passphrase tapi nggak mau ketik terus, kamu bisa pakai ssh-agent supaya passphrase hanya perlu dimasukkan sekali per sesi.\nContohnya:\n\n\nbash\n\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_rsa_main\n\nid_rsanya ada di sini.\nKemudian masukkan passphrase saat diminta. Setelah itu, Git bisa pakai SSH key-nya selama sesi terminal itu masih aktif."
  },
  {
    "objectID": "src/git/git.html#masukin-github",
    "href": "src/git/git.html#masukin-github",
    "title": "Git",
    "section": "Masukkin ke github",
    "text": "Masukkin ke github\n\n🔍 Pastikan file SSH key yang dimaksud memang ada Cek dulu apakah file private key ~/.ssh/id_rsa_main benar-benar ada:\n\n\n\nbash\n\nls ~/.ssh/id_rsa_main\n\nKalau tidak ada, berarti SSH key-nya belum dibuat atau salah nama.\nKalau ada, lanjut.\n\n📤 Tambahkan Public Key ke GitHub Ambil isi public key kamu:\n\n\n\nbash\n\ncat ~/.ssh/id_rsa_main.pub\n\nSalin hasilnya (mulai dari ssh-rsa …) dan:\nMasuk ke akun GitHub pertama (sesuai id_rsa_main)\nBuka: GitHub → Settings → SSH and GPG Keys → New SSH key\nBeri nama misal Laptop - SSH\nPaste public key tadi → Save\n\n\n\n\n\n\nCaution\n\n\n\n⚠️ Jangan sampai tertukar dengan akun GitHub kedua, karena SSH key ini hanya akan dikenali oleh akun GitHub tempat kamu mendaftarkannya.\n\n\n\n🔁 Uji Lagi Setelah menambahkan key ke akun GitHub, coba lagi:\n\n\n\nbash\n\nssh -T git@github-main\n\nKalau sukses, akan muncul:\n\n\nvbnet\n\nHi &lt;username&gt;! You've successfully authenticated, but GitHub does not provide shell access.\n\nItu artinya koneksi SSH berhasil dan GitHub kenal kamu. 🎉\nKalau kamu juga mau koneksi ke akun kedua (git@github-alt), ulangi proses di atas tapi dengan key id_ed25519_alt.pub dan tambahkan ke akun GitHub kedua.\nLalu, cek url remote\n\n\nbash\n\ngit remote -v\n\nKemungkinan hasilnya seperti:\n\n\nbash\n\norigin  git@github.com:username/repo.git (fetch)\norigin  git@github.com:username/repo.git (push)\n\nKita akan ubah itu agar pakai alias host yang benar dari ~/.ssh/config.\n\nGanti dengan Host Alias (misalnya github-main atau github-alt)\nMisalnya kamu pakai SSH key id_rsa_alt untuk akun kedua, dan di ~/.ssh/config kamu punya host:\n\n\nssh\n\nHost github-alt\n\nMaka kamu jalankan ini:\n\n\nssh\n\ngit remote set-url origin git@github-alt:username-kedua/nama-repo.git\n\ngantilah:\ngithub-alt → sesuai alias yang kamu tulis di ~/.ssh/config\nusername-kedua → username GitHub akun kedua\nnama-repo.git → nama repo yang sedang kamu kerjakan\n\nlalu bisa push deh\n\n\nbash\n\ngit push"
  },
  {
    "objectID": "src/git/git.html#lupa-ssh",
    "href": "src/git/git.html#lupa-ssh",
    "title": "Git",
    "section": "lupa alias ssh",
    "text": "lupa alias ssh\ntinggal\n\n\nbash\n\nnano ~/.ssh/config\n\natau pakai cat buat hanya lihat isinya:\n\n\nbash\n\ncat ~/.ssh/config\n\nakan tertampil\n\n\nbash\n\nHost github-main\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/id_rsa_main\n\nHost github-alt\n  ...\n\nAlias adalah bagian setelah Host, misalnya: github-main, github-alt, dll. Ini yang kamu pakai nanti seperti git@github-main:….\n\n\nKalau Punya Akun Ketiga, Alias-nya Apa?\nKamu bebas memberi alias apapun, tidak harus github-alt.\nMisalnya kamu ingin tambah akun ketiga, kamu bisa tambahkan blok baru seperti ini:\n\n\nbash\n\nHost github-third\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/id_ed25519_third\n  IdentitiesOnly yes\n\nLalu saat kloning atau set remote:\n\n\nbash\n\ngit clone git@github-third:username-ketiga/nama-repo.git\n\n\nYang penting:\n\n\nAlias github-third harus cocok dengan yang kamu tulis di file ~/.ssh/config\nGunakan ssh-keygen lagi untuk buat SSH key baru, contoh:\n\n\n\nbash\n\nssh-keygen -t ed25519 -C \"email-akun-ketiga@example.com\" -f ~/.ssh/id_rsa_third\n\n\n\nBisa Nggak Username Git (di git config) Beda dengan Username GitHub?\n✅ BISA, dan ini sering dilakukan.\nMisalnya:\n\n\nbash\n\ngit config user.name \"Mr. Robot\"\ngit config user.email \"robot@example.com\"\n\nItu hanya digunakan untuk mencatat siapa yang melakukan commit.\n\nTapi hati-hati: kalau kamu push ke GitHub, dan email robot@example.com tidak terdaftar di akun GitHub, maka commit-mu tidak akan muncul sebagai milik akun GitHub kamu, alias tidak ada foto profil atau identitasnya.\n\n\n\n\n\n\n\nTip\n\n\n\nUntuk setiap akun GitHub, daftarkan email yang kamu pakai untuk commit di sini: https://github.com/settings/emails\n\n\nDengan begitu, meskipun user.name kamu bebas, GitHub akan tetap mengenali commit kamu sebagai milik akun tersebut asal email-nya cocok."
  },
  {
    "objectID": "src/modstok/latihan-ctmc-1.html",
    "href": "src/modstok/latihan-ctmc-1.html",
    "title": "📝 CTMC",
    "section": "",
    "text": "Program Studi: S1 Statistika / S1 Aktuaria\nMata Kuliah: Model Stokastik I\nSemester: ATA 2024/2025"
  },
  {
    "objectID": "src/modstok/latihan-ctmc-1.html#soal-1-organisme-uniseluler-ctmc-dan-parameternya",
    "href": "src/modstok/latihan-ctmc-1.html#soal-1-organisme-uniseluler-ctmc-dan-parameternya",
    "title": "📝 CTMC",
    "section": "🧪 Soal 1: Organisme Uniseluler – CTMC dan Parameternya",
    "text": "🧪 Soal 1: Organisme Uniseluler – CTMC dan Parameternya\n\n📄 Deskripsi Masalah\nMisalkan sebuah organisme uniseluler dapat berada dalam salah satu dari dua state – yaitu A atau B:\n\nIndividu dalam state A akan berubah menjadi B dengan laju eksponensial sebesar \\(\\alpha\\).\nIndividu dalam state B akan membelah menjadi dua individu baru A dengan laju eksponensial sebesar \\(\\beta\\).\n\n🧠 Tentukan:\n\nModel Continuous-Time Markov Chain (CTMC) yang sesuai.\nParameter-parameter model (laju waktu tunggu dan probabilitas transisi).\n\n\n\n\n🔢 Definisi State\nKita modelkan proses ini dengan dua state:\n\nState 1: Organisme berada dalam kondisi A\nState 2: Organisme berada dalam kondisi B\n\nWalaupun B membelah menjadi dua A, untuk tujuan model ini kita anggap transisinya tetap kembali ke state A karena hanya satu organisme aktif dalam satu waktu.\n\n\n\n🔁 Diagram Transisi\n[A] --α--&gt; [B] --β--&gt; [A]\n\nTransisi dari A ke B terjadi dengan rate \\(\\alpha\\)\nTransisi dari B ke A (hasil pembelahan) terjadi dengan rate \\(\\beta\\)\n\n\n\n\n📊 Matriks Generator (Q)\n\\[Q =\n\\begin{bmatrix}\n-\\alpha & \\alpha \\\\\n\\beta & -\\beta\n\\end{bmatrix}\\]\n\nBaris pertama: Transisi dari A ke B\nBaris kedua: Transisi dari B ke A\n\nSetiap baris menjumlahkan ke nol, seperti properti matriks generator CTMC.\n\n\n\n⏱️ Laju Waktu Tunggu\nWaktu tunggu untuk berpindah dari suatu state mengikuti distribusi eksponensial.\n\nDari state A: waktu tunggu \\(\\sim \\text{Exp}(\\alpha)\\) ⟶ \\(\\mathbb{E}[T_A] = \\frac{1}{\\alpha}\\)\nDari state B: waktu tunggu \\(\\sim \\text{Exp}(\\beta)\\) ⟶ \\(\\mathbb{E}[T_B] = \\frac{1}{\\beta}\\)\n\n\n\n\n🎲 Probabilitas Transisi Instan\nDalam CTMC, probabilitas transisi dari state \\(i\\) ke \\(j\\) setelah waktu tunggu adalah:\n\\[ P_{ij} = \\frac{q_{ij}}{-q_{ii}} \\]\nUntuk model ini:\n\n\\(P_{A \\to B} = \\frac{\\alpha}{\\alpha} = 1\\)\n\\(P_{B \\to A} = \\frac{\\beta}{\\beta} = 1\\)\n\nArtinya, transisi bersifat deterministik setelah waktu tunggu eksponensialnya berakhir.\n\n\n\n✅ Kesimpulan\n\nModel CTMC terdiri dari dua state (A dan B) dengan transisi bolak-balik.\nLaju waktu tunggu tergantung dari parameter \\(\\alpha\\) dan \\(\\beta\\).\nProbabilitas transisi dari A ke B dan B ke A adalah 1, karena tidak ada alternatif transisi lain."
  },
  {
    "objectID": "src/modstok/latihan-ctmc-1.html#soal-2-dua-mesin-satu-teknisi-model-ctmc",
    "href": "src/modstok/latihan-ctmc-1.html#soal-2-dua-mesin-satu-teknisi-model-ctmc",
    "title": "📝 CTMC",
    "section": "🛠️ Soal 2: Dua Mesin & Satu Teknisi – Model CTMC",
    "text": "🛠️ Soal 2: Dua Mesin & Satu Teknisi – Model CTMC\n\n📄 Deskripsi Masalah\nMisalkan terdapat dua mesin yang dirawat oleh satu orang teknisi. Detail sistem adalah sebagai berikut:\n\nMesin ke-\\(i\\) (dengan \\(i = 1, 2\\)) akan berfungsi selama waktu eksponensial dengan parameter \\(\\mu_i\\) sebelum rusak.\nHanya satu teknisi yang tersedia untuk memperbaiki satu mesin dalam satu waktu, dengan waktu perbaikan berdistribusi eksponensial dengan rate \\(\\mu\\).\n\n🧠 Tentukan:\n\nDefinisi state dan model CTMC.\nLaju waktu tunggu dan probabilitas transisi antar state.\n\n\n\n\n🔢 Definisi State\nKita akan definisikan state berdasarkan jumlah mesin yang rusak dan diperbaiki. Karena teknisi hanya bisa memperbaiki satu mesin sekaligus, maka maksimal satu mesin dapat diperbaiki dalam satu waktu.\nMari kita gunakan representasi state sebagai:\n\n\\(0\\): Kedua mesin berfungsi\n\\(1\\): Satu mesin rusak (belum diperbaiki)\n\\(R\\): Satu mesin sedang diperbaiki\n\\(2\\): Kedua mesin rusak (satu diperbaiki, satu menunggu)\n\\(F\\): Kedua mesin berfungsi kembali\n\nNamun untuk CTMC formal, kita gunakan representasi berikut:\n\n\n\nState\nDeskripsi\n\n\n\n\n0\nKedua mesin berfungsi\n\n\n1\nSatu mesin rusak, menunggu perbaikan\n\n\n2\nSatu mesin rusak sedang diperbaiki\n\n\n3\nDua mesin rusak, satu sedang diperbaiki, satu menunggu\n\n\n\n\n\n\n🔁 Diagram Transisi (Secara Umum)\n\n0 → 1: Salah satu mesin rusak (rate = \\(\\mu_1 + \\mu_2\\))\n1 → 2: Teknisi mulai memperbaiki (rate = instanasi teknisi atau penggabungan, bisa diasumsikan cepat)\n2 → 0: Mesin selesai diperbaiki (rate = \\(\\mu\\))\n2 → 3: Mesin lainnya rusak saat satu sedang diperbaiki (rate = \\(\\mu_i\\), tergantung mesin yang masih berfungsi)\n3 → 1: Satu mesin selesai diperbaiki (rate = \\(\\mu\\))\n\n\n\n\n📊 Matriks Generator (Q)\nMisalkan kita menyederhanakan state menjadi:\n\n\\(S_0\\): 0 mesin rusak\n\\(S_1\\): 1 mesin rusak (belum diperbaiki)\n\\(S_2\\): 1 mesin rusak (dalam perbaikan)\n\\(S_3\\): 2 mesin rusak (1 diperbaiki, 1 menunggu)\n\nAsumsikan:\n\n\\(\\mu_1 = \\mu_2 = \\lambda\\) (simetris)\nRate perbaikan oleh teknisi: \\(\\mu\\)\n\nMaka estimasi matriks \\(Q\\) bisa berbentuk:\n\\[Q =\n\\begin{bmatrix}\n-2\\lambda & 2\\lambda & 0 & 0 \\\\\n0 & -\\mu & \\mu & 0 \\\\\n\\lambda & 0 & -(\\lambda + \\mu) & \\lambda \\\\\n0 & \\mu & 0 & -\\mu \\\\\n\\end{bmatrix}\\]\n\n\n\n⏱️ Laju Waktu Tunggu\nUntuk setiap state, waktu tunggu mengikuti eksponensial dengan parameter sama dengan jumlah keluarannya (jumlah total rate keluar dari state itu).\nContoh:\n\nDari state 0: rate keluar \\(= \\mu_1 + \\mu_2 = 2\\lambda\\) ⟶ \\(\\mathbb{E}[T_0] = \\frac{1}{2\\lambda}\\)\nDari state 2: rate keluar \\(= \\mu + \\lambda\\) ⟶ \\(\\mathbb{E}[T_2] = \\frac{1}{\\mu + \\lambda}\\)\n\n\n\n\n🎲 Probabilitas Transisi\nProbabilitas dari state \\(i\\) ke \\(j\\) adalah:\n\\[P_{ij} = \\frac{q_{ij}}{-q_{ii}}\\]\nContoh:\n\nDari state 0 ke 1: \\(P_{01} = \\frac{2\\lambda}{2\\lambda} = 1\\)\nDari state 2:\n\nke state 0: \\(P_{20} = \\frac{\\mu}{\\lambda + \\mu}\\)\nke state 3: \\(P_{23} = \\frac{\\lambda}{\\lambda + \\mu}\\)\n\n\n\n\n\n✅ Kesimpulan\n\nModel CTMC memuat empat state utama, yaitu jumlah mesin rusak dan apakah sedang diperbaiki.\nMatriks generator Q menunjukkan kemungkinan transisi dan laju waktunya.\nWaktu tunggu antar state mengikuti distribusi eksponensial berdasarkan total laju keluar dari state tersebut.\nProbabilitas transisi dihitung sebagai rasio dari rate transisi terhadap total rate keluar.\n\n🧩 Untuk hasil paling akurat, semua perhitungan dapat disesuaikan jika \\(\\mu_1 \\ne \\mu_2\\)."
  },
  {
    "objectID": "src/modstok/latihan-ctmc-1.html#soal-3-proses-kelahiran-dan-kematian-ekspektasi-variansi-waktu",
    "href": "src/modstok/latihan-ctmc-1.html#soal-3-proses-kelahiran-dan-kematian-ekspektasi-variansi-waktu",
    "title": "📝 CTMC",
    "section": "👶⚰️ Soal 3: Proses Kelahiran dan Kematian – Ekspektasi & Variansi Waktu",
    "text": "👶⚰️ Soal 3: Proses Kelahiran dan Kematian – Ekspektasi & Variansi Waktu\n\n📄 Deskripsi Masalah\nDiberikan sebuah proses kelahiran-kematian (birth-death process) dengan:\n\nBirth rate: \\(\\lambda_i = (i + 1)\\lambda\\), untuk \\(i \\geq 0\\)\nDeath rate: \\(\\mu_i = i\\mu\\), untuk \\(i \\geq 0\\)\n\n🧠 Tentukan:\n\n\nNilai harapan waktu untuk berpindah dari state 2 ke 5\n\n\nVariansi dari waktu tersebut\n\n\n\n\n\n🔢 Definisi Umum\nProses kelahiran-kematian ini adalah CTMC dengan state numerik tak hingga \\(i = 0, 1, 2, \\dots\\)\nDengan:\n\nTransisi ke atas: \\(i \\to i+1\\) dengan laju \\(\\lambda_i = (i+1)\\lambda\\)\nTransisi ke bawah: \\(i \\to i-1\\) dengan laju \\(\\mu_i = i\\mu\\)\n\n\n\n\n🧮 (a) Ekspektasi Waktu dari State 2 ke 5\nMisalkan \\(m(i)\\) adalah ekspektasi waktu untuk mencapai state 5 dari state \\(i\\).\nGunakan pendekatan rekursif dengan sistem persamaan:\nUntuk \\(i \\neq 5\\):\n\\[m(i) = \\frac{1}{\\lambda_i + \\mu_i} + \\frac{\\lambda_i}{\\lambda_i + \\mu_i} m(i+1) + \\frac{\\mu_i}{\\lambda_i + \\mu_i} m(i-1)\\]\nDengan \\(m(5) = 0\\) (karena target sudah tercapai).\n\n\n🔁 Langkah Penyelesaian\nKarena diminta dari state 2 ke 5, kita bentuk sistem persamaan untuk \\(m(2), m(3), m(4)\\):\n\nHitung laju:\n\n\\(\\lambda_2 = 3\\lambda\\), \\(\\mu_2 = 2\\mu\\)\n\\(\\lambda_3 = 4\\lambda\\), \\(\\mu_3 = 3\\mu\\)\n\\(\\lambda_4 = 5\\lambda\\), \\(\\mu_4 = 4\\mu\\)\n\nBentuk sistem:\n\n\\[\\begin{aligned}\nm(4) &= \\frac{1}{9\\lambda} + \\frac{5\\lambda}{9\\lambda} m(5) + \\frac{4\\lambda}{9\\lambda} m(3) \\\\\n     &= \\frac{1}{9\\lambda} + 0 + \\frac{4}{9} m(3) \\\\\nm(3) &= \\frac{1}{7\\lambda} + \\frac{4\\lambda}{7\\lambda} m(4) + \\frac{3\\lambda}{7\\lambda} m(2) \\\\\n     &= \\frac{1}{7\\lambda} + \\frac{4}{7} m(4) + \\frac{3}{7} m(2) \\\\\nm(2) &= \\frac{1}{5\\lambda} + \\frac{3\\lambda}{5\\lambda} m(3) + \\frac{2\\lambda}{5\\lambda} m(1)\n\\end{aligned}\\]\nNamun karena kita hanya diminta menghitung waktu dari \\(2 \\to 5\\), kita bisa selesaikan secara bertahap mundur dengan substitusi ke belakang:\n\\[m(4) = \\frac{1}{9\\lambda}\\]\n\\[m(3) = \\frac{1}{7\\lambda} + \\frac{4}{7} m(4) = \\frac{1}{7\\lambda} + \\frac{4}{7} \\cdot \\frac{1}{9\\lambda}\n= \\frac{1}{7\\lambda} + \\frac{4}{63\\lambda} = \\frac{9 + 4}{63\\lambda} = \\frac{13}{63\\lambda}\\]\n\\[m(2) = \\frac{1}{5\\lambda} + \\frac{3}{5} m(3) + \\frac{2}{5} m(1)\\]\nTAPI kita tidak tahu \\(m(1)\\) karena \\(m(2)\\) adalah titik awal kita. Maka kita batasi hanya pada langkah-langkah menuju 5 tanpa kemunduran, yaitu hanya jalur 2 → 3 → 4 → 5 (asumsi tidak pernah turun, transient path approximation).\nMaka pendekatannya:\n\\[\\mathbb{E}[T_{2 \\to 3}] = \\frac{1}{\\lambda_2} = \\frac{1}{3\\lambda}, \\quad\n\\mathbb{E}[T_{3 \\to 4}] = \\frac{1}{\\lambda_3} = \\frac{1}{4\\lambda}, \\quad\n\\mathbb{E}[T_{4 \\to 5}] = \\frac{1}{\\lambda_4} = \\frac{1}{5\\lambda}\\]\n\\[\\Rightarrow \\mathbb{E}[T_{2 \\to 5}] = \\frac{1}{3\\lambda} + \\frac{1}{4\\lambda} + \\frac{1}{5\\lambda}\n= \\frac{20 + 15 + 12}{60\\lambda} = \\frac{47}{60\\lambda}\\]\n\n\n\n\n📏 (b) Variansi Waktu dari State 2 ke 5\nKarena waktu antar transisi adalah independen, variansi total adalah jumlah variansi per langkah:\n\\[\\text{Var}(T_{2 \\to 5}) = \\text{Var}(T_{2 \\to 3}) + \\text{Var}(T_{3 \\to 4}) + \\text{Var}(T_{4 \\to 5})\\]\nUntuk peubah acak eksponensial dengan rate \\(\\lambda\\), variansinya adalah \\(\\frac{1}{\\lambda^2}\\). Maka:\n\\[\\text{Var}(T_{2 \\to 3}) = \\frac{1}{(3\\lambda)^2}, \\quad\n\\text{Var}(T_{3 \\to 4}) = \\frac{1}{(4\\lambda)^2}, \\quad\n\\text{Var}(T_{4 \\to 5}) = \\frac{1}{(5\\lambda)^2}\\]\n\\[\\Rightarrow \\text{Var}(T_{2 \\to 5}) = \\frac{1}{9\\lambda^2} + \\frac{1}{16\\lambda^2} + \\frac{1}{25\\lambda^2}\n= \\frac{400 + 225 + 144}{3600\\lambda^2} = \\frac{769}{3600\\lambda^2}\\]\n\n\n\n✅ Kesimpulan\n\n💡 Ekspektasi waktu dari state 2 ke 5:\n\\[\\mathbb{E}[T_{2 \\to 5}] = \\frac{47}{60\\lambda}\\]\n📊 Variansi waktu dari state 2 ke 5:\n\\[\\text{Var}(T_{2 \\to 5}) = \\frac{769}{3600\\lambda^2}\\]\n\nCatatan: Perhitungan ini menggunakan pendekatan hanya jalur naik (tanpa kemunduran), cocok untuk pendekatan eksak bila transisi ke bawah tidak signifikan atau jika soal tidak menyertakan \\(\\mu\\) sebagai besar."
  },
  {
    "objectID": "src/modstok/latihan-ctmc-1.html#soal-4-barbershop-kecil-ctmc-antrian-eksponensial",
    "href": "src/modstok/latihan-ctmc-1.html#soal-4-barbershop-kecil-ctmc-antrian-eksponensial",
    "title": "📝 CTMC",
    "section": "💈 Soal 4: Barbershop Kecil – CTMC Antrian Eksponensial",
    "text": "💈 Soal 4: Barbershop Kecil – CTMC Antrian Eksponensial\n\n📄 Deskripsi Masalah\nSebuah barbershop kecil hanya memiliki satu tukang cukur dan kapasitas maksimal 2 pelanggan di dalam. Detail sistem:\n\nPelanggan datang menurut proses Poisson dengan laju \\(3\\) orang per jam.\nWaktu pelayanan masing-masing pelanggan adalah eksponensial, rata-rata \\(\\frac{1}{4}\\) jam (artinya, laju pelayanan \\(\\mu = 4\\) pelanggan/jam).\nTidak ada ruang tunggu tambahan — pelanggan yang datang saat barbershop penuh akan pergi.\n\n🧠 Tentukan:\n\n\nJumlah rata-rata pelanggan dalam barbershop\n\n\nProporsi pelanggan potensial yang berhasil masuk\n\n\nTambahan bisnis jika tukang cukur bekerja 2× lebih cepat\n\n\n\n\n\n🧮 Step 1: Definisi Parameter\n\nLaju Kedatangan: \\(\\lambda = 3\\)/jam\n\nLaju Pelayanan: \\(\\mu = 4\\)/jam\n\nState Sistem:\n\n\\(0\\): Tidak ada pelanggan\n\n\\(1\\): 1 pelanggan (sedang dicukur)\n\n\\(2\\): 2 pelanggan (1 dicukur, 1 antri)\n\n\n\n\n\n📝 Step 2: Persamaan Keseimbangan\nUntuk probabilitas stasioner \\(\\pi_0, \\pi_1, \\pi_2\\):\n1. Dari state 0:\n\\[\n   \\lambda \\pi_0 = \\mu \\pi_1 \\quad \\Rightarrow \\quad \\pi_1 = \\frac{3}{4} \\pi_0\n   \\]\n2. Dari state 1:\n\\[\n   (\\lambda + \\mu) \\pi_1 = \\lambda \\pi_0 + \\mu \\pi_2 \\quad \\Rightarrow \\quad 7\\pi_1 = 3\\pi_0 + 4\\pi_2\n   \\]\n3. Dari state 2:\n\\[\n   \\mu \\pi_2 = \\lambda \\pi_1 \\quad \\Rightarrow \\quad \\pi_2 = \\frac{9}{16} \\pi_0\n   \\]\n\n\n\n🧮 Step 3: Hitung Probabilitas Stasioner\nSubstitusi ke \\(\\pi_0 + \\pi_1 + \\pi_2 = 1\\):\n\\[\n\\pi_0 \\left(1 + \\frac{3}{4} + \\frac{9}{16}\\right) = 1 \\quad \\Rightarrow \\quad \\pi_0 = \\frac{16}{37}, \\quad \\pi_1 = \\frac{12}{37}, \\quad \\pi_2 = \\frac{9}{37}\n\\]\n\n\n\n📊 Hasil Analisis\n\n\n\n\n\n\n\n\nParameter\nFormula\nNilai\n\n\n\n\nRata-Rata Pelanggan\n\\(0\\pi_0 + 1\\pi_1 + 2\\pi_2\\)\n\\(\\frac{30}{37} \\approx 0.81\\)\n\n\nProporsi Pelanggan Masuk\n\\(1 - \\pi_2\\)\n\\(\\frac{28}{37} \\approx 75.7\\%\\)\n\n\nPeningkatan Efisiensi ((= 8))\n\\(\\pi_2' = \\frac{9}{97}\\)\n\\(\\text{Kenaikan } 15\\%\\)\n\n\n\n\n\n\n\n\n\n\nCara Lain\n\n\n\n\n\n\n🔢 Definisi State\nKita definisikan state \\(i\\) sebagai jumlah pelanggan di dalam barbershop (termasuk yang sedang dicukur):\n\n\n\nState \\(i\\)\nDeskripsi\n\n\n\n\n\\(0\\)\nTidak ada pelanggan\n\n\n\\(1\\)\n1 pelanggan (dalam servis)\n\n\n\\(2\\)\n2 pelanggan (1 diservis, 1 menunggu)\n\n\n\n\n\n\n🔁 Diagram Transisi (CTMC)\n\nKedatangan pelanggan (Poisson, \\(\\lambda = 3\\) per jam)\nPelayanan pelanggan (Eksponensial, \\(\\mu = 4\\) per jam)\n\nTransisi:\n[0] --λ--&gt; [1] --λ--&gt; [2]\n ↑         ↓μ         ↓μ\n ←---------←----------←\n\n\n\n📊 Matriks Generator (Q)\n\\[Q =\n\\begin{bmatrix}\n-3 & 3 & 0 \\\\\n4 & -7 & 3 \\\\\n0 & 4 & -4\n\\end{bmatrix}\\]\nBaris \\(i\\) mewakili laju keluar dari state \\(i\\), dan kolom mewakili tujuan transisi.\n\n\n\n🔍 Distribusi State Stasioner (π)\nKita gunakan keseimbangan global untuk mencari probabilitas stasioner \\(\\pi_0\\), \\(\\pi_1\\), \\(\\pi_2\\).\n\\[\\begin{aligned}\n\\pi_1 &= \\frac{\\lambda}{\\mu} \\pi_0 = \\frac{3}{4} \\pi_0 \\\\\n\\pi_2 &= \\frac{\\lambda}{\\mu} \\pi_1 = \\frac{3}{4} \\cdot \\frac{3}{4} \\pi_0 = \\left( \\frac{3}{4} \\right)^2 \\pi_0 = \\frac{9}{16} \\pi_0\n\\end{aligned}\\]\nGunakan kondisi total probabilitas:\n\\[\\pi_0 + \\pi_1 + \\pi_2 = 1\n\\Rightarrow \\pi_0 + \\frac{3}{4} \\pi_0 + \\frac{9}{16} \\pi_0 = 1\n\\Rightarrow \\pi_0 \\left(1 + \\frac{3}{4} + \\frac{9}{16} \\right) = 1\n\\Rightarrow \\pi_0 \\cdot \\frac{61}{16} = 1\n\\Rightarrow \\pi_0 = \\frac{16}{61}\\]\nSehingga:\n\\[\\pi_1 = \\frac{3}{4} \\cdot \\frac{16}{61} = \\frac{48}{61}, \\quad\n\\pi_2 = \\frac{9}{16} \\cdot \\frac{16}{61} = \\frac{9}{61}\\]\n\n\n\n🧮 (a) Rata-rata Pelanggan di Barbershop\n\\[\\mathbb{E}[N] = 0 \\cdot \\pi_0 + 1 \\cdot \\pi_1 + 2 \\cdot \\pi_2 = 0 + \\frac{48}{61} + 2 \\cdot \\frac{9}{61} = \\frac{48 + 18}{61} = \\frac{66}{61} \\approx 1.082\\]\n\n\n\n🚪 (b) Proporsi Pelanggan yang Berhasil Masuk\nPelanggan hanya ditolak saat state = 2. Jadi proporsi yang berhasil masuk:\n\\[1 - \\pi_2 = 1 - \\frac{9}{61} = \\frac{52}{61} \\approx 0.852\\]\nArtinya, sekitar 85.2% pelanggan berhasil masuk ke barbershop.\n\n\n\n⚡ (c) Tukang Cukur Bekerja 2× Lebih Cepat\nJika \\(\\mu = 8\\) (bukan 4):\n\\[\\rho = \\frac{\\lambda}{\\mu} = \\frac{3}{8}\\]\nHitung ulang distribusi stasioner:\n\\[\\pi_1 = \\frac{3}{8} \\pi_0, \\quad\n\\pi_2 = \\left( \\frac{3}{8} \\right)^2 \\pi_0 = \\frac{9}{64} \\pi_0\\]\n\\[\\pi_0 + \\pi_1 + \\pi_2 = \\pi_0 \\left(1 + \\frac{3}{8} + \\frac{9}{64} \\right)\n= \\pi_0 \\cdot \\frac{121}{64} = 1\n\\Rightarrow \\pi_0 = \\frac{64}{121}\\]\n\\[\\pi_2 = \\frac{9}{64} \\cdot \\frac{64}{121} = \\frac{9}{121}\n\\Rightarrow \\text{Proporsi masuk} = 1 - \\frac{9}{121} = \\frac{112}{121} \\approx 0.926\\]\n🧮 Tambahan bisnis:\n\\[\\text{Tambahan proporsi masuk} = \\frac{112}{121} - \\frac{52}{61} = \\approx 0.926 - 0.852 = 0.074\\]\nArtinya, ada peningkatan pelanggan masuk sekitar 7.4% jika tukang cukur bekerja dua kali lebih cepat.\n\n\n\n\n\n\n\n✅ Kesimpulan\n\n📊 Rata-rata pelanggan dalam barbershop: \\(\\frac{66}{61} \\approx 1.082\\)\n🚶 Proporsi pelanggan yang berhasil masuk: \\(\\frac{52}{61} \\approx 85.2\\%\\)\n⚡ Jika tukang cukur lebih cepat 2×, proporsi masuk naik jadi \\(\\approx 92.6\\%\\) (kenaikan ~7.4%)"
  },
  {
    "objectID": "src/modstok/rantai-markov-waktu-kontinu.html#limiting-probabilities",
    "href": "src/modstok/rantai-markov-waktu-kontinu.html#limiting-probabilities",
    "title": "rantai markov waktu kontinu",
    "section": "6.5 Limiting Probabilities",
    "text": "6.5 Limiting Probabilities\nIn analogy with a basic result in discrete-time Markov chains, the probability that a continuous-time Markov chain will be in state \\(j\\) at time \\(t\\) often converges to a limiting value that is independent of the initial state. That is, if we call this value \\(P_j\\), then \\[\nP_j \\equiv \\lim_{t \\to \\infty} P_{ij}(t)\n\\] where we assume the limit exists and is independent of the initial state \\(i\\).\nTo derive a set of equations for the \\(P_j\\), consider the forward equations: \\[\n\\frac{d}{dt} P_{ij}(t) = \\sum_{k \\ne j} q_{kj} P_{ik}(t) - \\nu_j P_{ij}(t) \\tag{6.17}\n\\]\nLetting \\(t \\to \\infty\\) and assuming we can interchange the limit and summation: \\[\n\\lim_{t \\to \\infty} \\frac{d}{dt} P_{ij}(t) = \\sum_{k \\ne j} q_{kj} P_k - \\nu_j P_j\n\\]\nBut since \\(P_{ij}(t)\\) is a bounded function, its derivative must converge to 0: \\[\n0 = \\sum_{k \\ne j} q_{kj} P_k - \\nu_j P_j\n\\]\nThat is, \\[\n\\nu_j P_j = \\sum_{k \\ne j} q_{kj} P_k, \\quad \\text{for all states } j \\tag{6.18}\n\\]\nAlong with the normalization condition: \\[\n\\sum_j P_j = 1 \\tag{6.19}\n\\]\nThis system can be used to solve for the limiting probabilities.\n\nRemarks:\n\nWe have assumed that the limiting probabilities \\(P_j\\) exist. A sufficient condition is:\n\n\n\nAll states communicate (i.e., from any state \\(i\\) there’s positive probability of reaching any \\(j\\)).\n\n\nThe chain is positive recurrent (the mean return time to any state is finite).\n\n\nIf (a) and (b) hold, then \\(P_j\\) exists, satisfies (6.18) and (6.19), and \\(P_j\\) also represents the long-run proportion of time spent in state \\(j\\).\n\nEq. (6.18) has a balance equation interpretation:\nIn the long run, the rate at which transitions enter state \\(j\\) equals the rate at which transitions leave state \\(j\\):\n\n\nRate leaving state \\(j\\): \\(\\nu_j P_j\\)\nRate entering from \\(k\\): \\(q_{kj} P_k\\) Thus: \\[\n\\sum_{k \\ne j} q_{kj} P_k = \\nu_j P_j\n\\]\n\n\n\nLimiting Probabilities for a Birth and Death Process\nFrom (6.18), or by balancing rate in = rate out, we obtain:\n\n\n\nState\nLeave rate = Enter rate\n\n\n\n\n0\n\\(\\lambda_0 P_0 = \\mu_1 P_1\\)\n\n\n1\n\\((\\lambda_1 + \\mu_1) P_1 = \\mu_2 P_2 + \\lambda_0 P_0\\)\n\n\n2\n\\((\\lambda_2 + \\mu_2) P_2 = \\mu_3 P_3 + \\lambda_1 P_1\\)\n\n\n\\(\\cdots\\)\n\\(\\cdots\\)\n\n\n\nAdding each equation to the previous yields: \\[\n\\lambda_0 P_0 = \\mu_1 P_1 \\\\\n\\lambda_1 P_1 = \\mu_2 P_2 \\\\\n\\lambda_2 P_2 = \\mu_3 P_3 \\\\\n\\vdots\n\\]\nSolving recursively in terms of \\(P_0\\): \\[\nP_1 = \\frac{\\lambda_0}{\\mu_1} P_0 \\\\\nP_2 = \\frac{\\lambda_1}{\\mu_2} P_1 = \\frac{\\lambda_1 \\lambda_0}{\\mu_2 \\mu_1} P_0 \\\\\n\\cdots \\\\\nP_n = \\frac{\\lambda_0 \\lambda_1 \\cdots \\lambda_{n-1}}{\\mu_1 \\mu_2 \\cdots \\mu_n} P_0\n\\]\nUsing normalization \\(\\sum_{n=0}^\\infty P_n = 1\\): \\[\nP_0 = \\left( 1 + \\sum_{n=1}^\\infty \\frac{\\lambda_0 \\lambda_1 \\cdots \\lambda_{n-1}}{\\mu_1 \\mu_2 \\cdots \\mu_n} \\right)^{-1}\n\\]\nSo: \\[\nP_n = \\frac{\\lambda_0 \\cdots \\lambda_{n-1}}{\\mu_1 \\cdots \\mu_n} P_0, \\quad n \\ge 1 \\tag{6.20}\n\\]\nExistence condition:\nThe limiting probabilities exist if: \\[\n\\sum_{n=1}^\\infty \\frac{\\lambda_0 \\cdots \\lambda_{n-1}}{\\mu_1 \\cdots \\mu_n} &lt; \\infty \\tag{6.21}\n\\]\n\n\n\nExamples:\nMultiserver Exponential Queue (Example 6.6):\nCondition (6.21) reduces to: \\[\n\\sum_{n=s+1}^\\infty \\frac{\\lambda^n}{(s\\mu)^n} &lt; \\infty\n\\quad \\Rightarrow \\quad \\lambda &lt; s\\mu\n\\]\n\nLinear Growth Model with Immigration (Example 6.4):\nCondition (6.21) becomes: \\[\n\\sum_{n=1}^\\infty \\frac{\\theta(\\theta + \\lambda) \\cdots (\\theta + (n - 1)\\lambda)}{n! \\mu^n}\n\\]\nApply ratio test: \\[\n\\lim_{n \\to \\infty} \\frac{\\theta + n\\lambda}{(n + 1)\\mu} = \\frac{\\lambda}{\\mu} &lt; 1\n\\quad \\Rightarrow \\text{Converges if } \\lambda &lt; \\mu\n\\]\n\n\n\nExample 6.13 (Machine Repair Model)\n\n\\(M\\) machines, one repairman\nTime to fail: \\(\\text{Exp}(1/\\lambda)\\), repair time: \\(\\text{Exp}(1/\\mu)\\)\nLet state \\(n\\) be the number of failed machines\n\nParameters: - \\(\\mu_n = \\mu\\), \\(n \\ge 1\\) - \\(\\lambda_n = (M - n)\\lambda\\), \\(n \\le M\\); \\(\\lambda_n = 0\\) otherwise\nFrom (6.20): - \\(P_0 = \\left(1 + \\sum_{n=1}^M \\frac{(M\\lambda)(M-1)\\lambda \\cdots (M - n + 1)\\lambda}{\\mu^n} \\right)^{-1}\\) - Simplifies to: \\[\n  P_0 = \\left(1 + \\sum_{n=1}^M \\frac{(\\lambda/\\mu)^n M!}{(M - n)!} \\right)^{-1}\n  \\] \\[\n  P_n = \\frac{(\\lambda/\\mu)^n M!}{(M - n)!} \\cdot P_0, \\quad n = 0, \\dots, M\n  \\]\nAverage number of machines not in use: \\[\n\\sum_{n=0}^M n P_n = \\frac{\\sum_{n=0}^M n (\\lambda/\\mu)^n M! / (M - n)!}{1 + \\sum_{n=1}^M (\\lambda/\\mu)^n M! / (M - n)!} \\tag{6.22}\n\\]\nProportion of time a given machine is working: \\[\n1 - \\frac{1}{M} \\sum_{n=0}^M n P_n\n\\]\n\n\n\nExample 6.14 (The M/M/1 Queue)\n\n\\(\\lambda_n = \\lambda\\), \\(\\mu_n = \\mu\\)\nFrom (6.20): \\[\nP_n = \\frac{(\\lambda/\\mu)^n}{1 + \\sum_{k=1}^\\infty (\\lambda/\\mu)^k} = (\\lambda/\\mu)^n (1 - \\lambda/\\mu), \\quad n \\ge 0\n\\]\nValid only if \\(\\lambda &lt; \\mu\\).\n\n\n\n\nExample 6.15 (Shoe Shine Shop)\n\n3 states: 0, 1, 2 (number of customers)\nTransitions: 2 → 0 possible, not birth-death\nUse balance equations:\n\n\n\n\nState\nLeave rate = Enter rate\n\n\n\n\n0\n\\(\\lambda P_0 = \\mu_2 P_2\\)\n\n\n1\n\\(\\mu_1 P_1 = \\lambda P_0\\)\n\n\n2\n\\(\\mu_2 P_2 = \\mu_1 P_1\\)\n\n\n\nSolve: - \\(P_1 = \\frac{\\lambda}{\\mu_1} P_0\\), \\(P_2 = \\frac{\\lambda}{\\mu_2} P_0\\)\nNormalize: \\[\nP_0 = \\frac{\\mu_1 \\mu_2}{\\mu_1 \\mu_2 + \\lambda (\\mu_1 + \\mu_2)}\n\\]\nSo: \\[\nP_1 = \\frac{\\lambda \\mu_2}{\\mu_1 \\mu_2 + \\lambda (\\mu_1 + \\mu_2)}, \\quad\nP_2 = \\frac{\\lambda \\mu_1}{\\mu_1 \\mu_2 + \\lambda (\\mu_1 + \\mu_2)}\n\\]\n\n\n\nExample 6.16 (Preemptive Repair with n Components)\n\n\\(n\\) components, one repairman\nEach component \\(i\\) fails with rate \\(\\lambda_i\\), repaired with rate \\(\\mu_i\\)\nMost recent failure is repaired first (preemption allowed)\nState: ordered list of failed components\n\nNumber of states: \\[\n\\sum_{k=0}^n \\binom{n}{k} k! = n! \\sum_{i=0}^n \\frac{1}{i!}\n\\]\nLet \\(P(i_1, ..., i_k)\\) be the steady-state probability of state \\((i_1, ..., i_k)\\).\nBalance equations: - Exit rate from \\((i_1, ..., i_k)\\): \\[\n  \\mu_{i_1} + \\sum_{\\substack{i \\ne i_j \\\\ j=1..k}} \\lambda_i\n  \\] - Entry: - From \\((i_2, ..., i_k)\\) if \\(i_1\\) fails - From \\((i, i_1, ..., i_k)\\) if \\(i\\) (not in list) is repaired\nLet \\[\nP(i_1, ..., i_k) = \\frac{\\lambda_{i_1} \\cdots \\lambda_{i_k}}{\\mu_{i_1} \\cdots \\mu_{i_k}} P(\\varnothing) \\tag{6.24}\n\\]\nNormalization: \\[\nP(\\varnothing) = \\left[ 1 + \\sum_{i_1,...,i_k} \\frac{\\lambda_{i_1} \\cdots \\lambda_{i_k}}{\\mu_{i_1} \\cdots \\mu_{i_k}} \\right]^{-1}\n\\]\nExample with \\(n = 2\\): states: \\(\\varnothing\\), 1, 2, 12, 21\n\n\\(P(1) = \\frac{\\lambda_1}{\\mu_1} P(\\varnothing)\\)\n\\(P(2) = \\frac{\\lambda_2}{\\mu_2} P(\\varnothing)\\)\n\\(P(1,2) = P(2,1) = \\frac{\\lambda_1 \\lambda_2}{\\mu_1 \\mu_2} P(\\varnothing)\\)\nNormalize: \\[\nP(\\varnothing) = \\left[ 1 + \\frac{\\lambda_1}{\\mu_1} + \\frac{\\lambda_2}{\\mu_2} + 2 \\cdot \\frac{\\lambda_1 \\lambda_2}{\\mu_1 \\mu_2} \\right]^{-1}\n\\]\n\nObservation: given the set of failed components, all orderings are equally likely.\n\nWhen the limiting probabilities exist, we say the chain is ergodic. The \\(P_j\\) are also called stationary probabilities, because if the chain starts in state \\(j\\) with probability \\(P_j\\), then: \\[\n\\mathbb{P}(X(t) = j) = P_j, \\quad \\text{for all } t\n\\]\nVerification: Assume initial state distributed as \\(\\{P_j\\}\\): \\[\n\\mathbb{P}(X(t) = j) = \\sum_k P_{kj}(t) P_k = \\lim_{s \\to \\infty} \\sum_k P_{kj}(t) P_{ik}(s) = \\lim_{s \\to \\infty} P_{ij}(t + s) = P_j\n\\] (by Chapman–Kolmogorov and limit properties)"
  },
  {
    "objectID": "src/modstok/rantai-markov-waktu-kontinu.html#time-reversibility",
    "href": "src/modstok/rantai-markov-waktu-kontinu.html#time-reversibility",
    "title": "rantai markov waktu kontinu",
    "section": "6.6 Time Reversibility",
    "text": "6.6 Time Reversibility\nConsider a continuous-time Markov chain that is ergodic, and let \\(P_i\\) denote its limiting probabilities. If we ignore the time spent in each state and just look at the sequence of states visited, it forms a discrete-time Markov chain (called the embedded chain) with transition probabilities \\(P_{ij}\\). Let \\(\\pi_i\\) be the limiting probabilities of this embedded chain, satisfying:\n\\[\n\\pi_i = \\sum_j \\pi_j P_{ji}, \\quad \\sum_i \\pi_i = 1\n\\]\nSince \\(\\pi_i\\) is the proportion of transitions into state \\(i\\), and \\(1/\\nu_i\\) is the mean time spent in state \\(i\\) per visit, it’s intuitive that \\(P_i\\), the proportion of time in state \\(i\\), is:\n\\[\nP_i = \\frac{\\pi_i / \\nu_i}{\\sum_j \\pi_j / \\nu_j} \\tag{6.25}\n\\]\nThis is confirmed via the balance equation: \\[\n\\nu_i P_i = \\sum_{j \\ne i} P_j q_{ji} = \\sum_j P_j \\nu_j P_{ji}\n\\]\nSuppose the chain is observed in steady state, and we reverse time from some time \\(T\\). The reversed process is also a continuous-time Markov chain, with: - Sojourn times in each state still exponential with rate \\(\\nu_i\\) - Transition probabilities: \\[\nQ_{ij} = \\frac{\\pi_j P_{ji}}{\\pi_i}\n\\]\nThus, the reversed process has same rates and is time reversible if: \\[\n\\pi_i P_{ij} = \\pi_j P_{ji}, \\quad \\forall i, j\n\\]\nGiven: \\[\nP_i = \\frac{\\pi_i / \\nu_i}{\\sum_j \\pi_j / \\nu_j}\n\\]\nThis condition becomes: \\[\nP_i q_{ij} = P_j q_{ji} \\tag{6.26}\n\\]\nInterpretation:\nIn time-reversible chains, the rate of direct transitions from \\(i\\) to \\(j\\) equals the rate from \\(j\\) to \\(i\\).\n\n\nProposition 6.5\nAn ergodic birth and death process is time reversible.\nProof sketch: In any interval, the number of transitions from \\(i\\) to \\(i+1\\) differs by at most 1 from transitions from \\(i+1\\) to \\(i\\). Hence, over long time, their rates must be equal.\n\n\n\nCorollary 6.6\nIn an M/M/s queue with \\(\\lambda &lt; s\\mu\\), the departure process is a Poisson process with rate \\(\\lambda\\) (in steady state).\nReason: The process is time reversible. In forward time, arrivals are Poisson. So in reverse, “arrivals” are actually departures in forward time ⇒ Poisson.\n\n\n\nExample 6.17 (Queue Occupancy Interpretation)\nLet C be a customer in an M/M/1 queue with arrival rate \\(\\lambda\\) and service rate \\(\\mu\\) (\\(\\lambda &lt; \\mu\\)). Given that C spends time \\(t\\) in the system, what’s the distribution of the number of others present at their arrival?\nSolution:\nBy reversibility, number of departures in \\((s, s+t)\\) is equal in distribution to number of arrivals in that interval in the reversed process. Thus, this number is Poisson(\\(\\lambda t\\)).\n\n\nProposition 6.7\nSuppose that an ergodic continuous-time Markov chain has transition rates \\(q_{ij}\\) and limiting probabilities \\(P_i\\). If \\[\nP_i q_{ij} = P_j q_{ji} \\quad \\text{for all } i, j \\tag{6.27}\n\\] then the process is time reversible.\nProof sketch:\nFrom this condition, it’s easy to verify that the reversed process has the same dynamics as the forward process. Specifically, the reversed transition rates \\(q_{ij}^*\\) become: \\[\nq_{ij}^* = \\frac{P_j q_{ji}}{P_i} = q_{ij}\n\\] Thus, the reversed process has the same generator matrix \\(Q\\), hence same law.\n\n\n\nExample 6.18 (Two-Server Queue)\nA two-server queue has a maximum of three customers. Arrivals follow a Poisson process with rate \\(\\lambda\\) and service is exponential with rate \\(\\mu\\) per server.\nStates: 0, 1, 2, 3 (number of customers)\nTransition diagram: - \\(0 \\xrightarrow{\\lambda} 1\\) - \\(1 \\xrightarrow{\\lambda} 2\\), \\(1 \\xrightarrow{\\mu} 0\\) - \\(2 \\xrightarrow{\\lambda} 3\\), \\(2 \\xrightarrow{2\\mu} 1\\) - \\(3 \\xrightarrow{2\\mu} 2\\)\nLet’s check time reversibility: - Solve for stationary probabilities: \\[\n  P_1 = \\frac{\\lambda}{\\mu} P_0,\\quad\n  P_2 = \\frac{\\lambda}{2\\mu} P_1 = \\frac{\\lambda^2}{2\\mu^2} P_0,\\quad\n  P_3 = \\frac{\\lambda}{2\\mu} P_2 = \\frac{\\lambda^3}{4\\mu^3} P_0\n  \\]\nNormalization: \\[\nP_0 = \\left(1 + \\frac{\\lambda}{\\mu} + \\frac{\\lambda^2}{2\\mu^2} + \\frac{\\lambda^3}{4\\mu^3}\\right)^{-1}\n\\]\nNow check detailed balance: \\[\nP_0 \\cdot \\lambda = P_1 \\cdot \\mu \\quad \\text{✓} \\\\\nP_1 \\cdot \\lambda = P_2 \\cdot 2\\mu \\quad \\text{✓} \\\\\nP_2 \\cdot \\lambda = P_3 \\cdot 2\\mu \\quad \\text{✓}\n\\]\nThus, the process is time reversible.\n\n\n\nExample 6.19 (Jackson Network)\nLet a network consist of \\(n\\) service stations. Customers: - arrive from outside to station \\(i\\) at rate \\(r_i\\), - get served (service rate \\(\\mu_i\\)), - then with probability \\(P_{ij}\\) go to station \\(j\\), or - with probability \\(1 - \\sum_j P_{ij}\\) leave the system.\nLet \\(\\lambda_i\\) be the total arrival rate to station \\(i\\) (external + internal). Then: \\[\n\\lambda_i = r_i + \\sum_{j=1}^n \\lambda_j P_{ji}\n\\]\nThis is a system of traffic equations. Once solved, define the utilization of station \\(i\\): \\[\n\\rho_i = \\frac{\\lambda_i}{\\mu_i}\n\\]\nIf all \\(\\rho_i &lt; 1\\), then in steady state the queue at station \\(i\\) behaves like an M/M/1 queue.\nThe network has product-form solution: \\[\nP(n_1, ..., n_n) = \\prod_{i=1}^n (1 - \\rho_i) \\rho_i^{n_i}\n\\]\nThis process is not time reversible in general (because the routing matrix \\(P_{ij}\\) may not be symmetric), but the stationary distribution still exists and has a nice form.\n\n\n\nSummary: Time Reversibility\n\nA continuous-time Markov chain is time reversible if: \\[\nP_i q_{ij} = P_j q_{ji}, \\quad \\text{for all } i, j\n\\]\nTime-reversible chains have a particularly simple form of the balance equations\nCommon reversible examples:\n\nBirth–death processes\nM/M/s queues\nSome queueing networks with symmetric routing"
  },
  {
    "objectID": "src/modstok/rantai-markov-waktu-kontinu.html#applications-of-continuous-time-markov-chains",
    "href": "src/modstok/rantai-markov-waktu-kontinu.html#applications-of-continuous-time-markov-chains",
    "title": "rantai markov waktu kontinu",
    "section": "6.7 Applications of Continuous-Time Markov Chains",
    "text": "6.7 Applications of Continuous-Time Markov Chains\nWe now consider some practical applications of the theory of continuous-time Markov chains.\n\n\nExample 6.20 (Switching Between Two Machines)\nA factory has two machines, A and B. Only one is operated at a time. When A is operating, it breaks down at rate \\(\\lambda_1\\), and when B is operating, it breaks down at rate \\(\\lambda_2\\). When a machine breaks, the other is repaired and operation switches to that one. The time to repair is negligible.\nState description:\nLet the state be the currently running machine: state 1 = A, state 2 = B.\nTransition rates: - From state 1 to 2: \\(\\lambda_1\\) - From state 2 to 1: \\(\\lambda_2\\)\nThis forms a two-state continuous-time Markov chain.\nLimiting probabilities: - Let \\(P_1\\) and \\(P_2\\) be the steady-state probabilities.\nFrom balance: \\[\n\\lambda_1 P_1 = \\lambda_2 P_2\n\\]\nWith \\(P_1 + P_2 = 1\\): \\[\nP_1 = \\frac{\\lambda_2}{\\lambda_1 + \\lambda_2}, \\quad P_2 = \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2}\n\\]\nSo the long-run proportion of time that machine A is operating is \\(P_1\\).\n\n\n\nExample 6.21 (System Availability)\nA two-unit system operates as long as at least one unit is operational.\nEach unit: - fails with rate \\(\\lambda\\) - is repaired with rate \\(\\mu\\)\nIf both are operational, the failure of either results in a transition to one unit working. If only one is working and it fails, system is down.\nStates: - 2: both working\n- 1: one working\n- 0: both failed\nTransitions: - \\(2 \\to 1\\) with rate \\(2\\lambda\\) - \\(1 \\to 0\\) with rate \\(\\lambda\\) - \\(1 \\to 2\\) with rate \\(\\mu\\) - \\(0 \\to 1\\) with rate \\(\\mu\\)\nBalance equations: Let \\(P_0\\), \\(P_1\\), \\(P_2\\) be steady-state probabilities.\nFrom flow balance: - \\(\\lambda P_1 = \\mu P_0\\) - \\(2\\lambda P_2 = \\mu P_1\\) - \\(P_0 + P_1 + P_2 = 1\\)\nSolve: 1. \\(P_0 = \\frac{\\lambda}{\\mu} P_1\\) 2. \\(P_2 = \\frac{\\mu}{2\\lambda} P_1\\)\nSubstitute into normalization: \\[\n\\frac{\\lambda}{\\mu} P_1 + P_1 + \\frac{\\mu}{2\\lambda} P_1 = 1 \\Rightarrow P_1 \\left( \\frac{\\lambda}{\\mu} + 1 + \\frac{\\mu}{2\\lambda} \\right) = 1\n\\]\nSolve for \\(P_1\\), then: \\[\nP_{\\text{up}} = P_1 + P_2 = 1 - P_0\n\\]\nThis gives long-run availability of the system.\n\n\n\nExample 6.22 (Computer Virus Spread)\nA network of \\(n\\) computers. Any infected computer can infect any uninfected one at rate \\(\\lambda\\), and any infected computer gets cleaned at rate \\(\\mu\\).\nLet \\(X(t)\\) be the number of infected computers at time \\(t\\). Then \\(\\{X(t)\\}\\) is a birth–death process on states \\(0\\) to \\(n\\), with:\n\n\\(\\lambda_i = \\lambda i (n - i)\\): \\(i\\) infected can infect \\((n - i)\\) others\n\\(\\mu_i = \\mu i\\): each infected gets cleaned\n\nGoal: find the expected time to infection extinction starting from \\(i\\) infected computers.\nLet \\(m_i = \\mathbb{E}[\\text{time until absorption at 0} \\mid X(0) = i]\\)\nRecursion: \\[\nm_0 = 0 \\\\\nm_i = \\frac{1}{\\lambda_i + \\mu_i} + \\frac{\\lambda_i}{\\lambda_i + \\mu_i} m_{i+1} + \\frac{\\mu_i}{\\lambda_i + \\mu_i} m_{i-1}, \\quad i = 1, \\dots, n-1 \\\\\nm_n = \\frac{1}{\\mu_n} + m_{n-1}\n\\]\nThis is a standard way to compute expected hitting times in birth–death processes.\n\n\n\nApplication Notes\nThe above examples illustrate: - Modeling with CTMCs by carefully defining states and transition rates - Using limiting probabilities for long-run behavior - Using first-step analysis and recurrence relations to solve for expectations - Relevance to systems reliability, networking, queueing, and more"
  },
  {
    "objectID": "src/modstok/rantai-markov-waktu-kontinu.html#applications-of-continuous-time-markov-chains-1",
    "href": "src/modstok/rantai-markov-waktu-kontinu.html#applications-of-continuous-time-markov-chains-1",
    "title": "rantai markov waktu kontinu",
    "section": "6.7 Applications of Continuous-Time Markov Chains",
    "text": "6.7 Applications of Continuous-Time Markov Chains\nWe now consider some practical applications of the theory of continuous-time Markov chains.\n\n\nExample 6.20 (Switching Between Two Machines)\nA factory has two machines, A and B. Only one is operated at a time. When A is operating, it breaks down at rate \\(\\lambda_1\\), and when B is operating, it breaks down at rate \\(\\lambda_2\\). When a machine breaks, the other is repaired and operation switches to that one. The time to repair is negligible.\nState description:\nLet the state be the currently running machine: state 1 = A, state 2 = B.\nTransition rates: - From state 1 to 2: \\(\\lambda_1\\) - From state 2 to 1: \\(\\lambda_2\\)\nThis forms a two-state continuous-time Markov chain.\nLimiting probabilities: - Let \\(P_1\\) and \\(P_2\\) be the steady-state probabilities.\nFrom balance: \\[\n\\lambda_1 P_1 = \\lambda_2 P_2\n\\]\nWith \\(P_1 + P_2 = 1\\): \\[\nP_1 = \\frac{\\lambda_2}{\\lambda_1 + \\lambda_2}, \\quad P_2 = \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2}\n\\]\nSo the long-run proportion of time that machine A is operating is \\(P_1\\).\n\n\n\nExample 6.21 (System Availability)\nA two-unit system operates as long as at least one unit is operational.\nEach unit: - fails with rate \\(\\lambda\\) - is repaired with rate \\(\\mu\\)\nIf both are operational, the failure of either results in a transition to one unit working. If only one is working and it fails, system is down.\nStates: - 2: both working\n- 1: one working\n- 0: both failed\nTransitions: - \\(2 \\to 1\\) with rate \\(2\\lambda\\) - \\(1 \\to 0\\) with rate \\(\\lambda\\) - \\(1 \\to 2\\) with rate \\(\\mu\\) - \\(0 \\to 1\\) with rate \\(\\mu\\)\nBalance equations: Let \\(P_0\\), \\(P_1\\), \\(P_2\\) be steady-state probabilities.\nFrom flow balance: - \\(\\lambda P_1 = \\mu P_0\\) - \\(2\\lambda P_2 = \\mu P_1\\) - \\(P_0 + P_1 + P_2 = 1\\)\nSolve: 1. \\(P_0 = \\frac{\\lambda}{\\mu} P_1\\) 2. \\(P_2 = \\frac{\\mu}{2\\lambda} P_1\\)\nSubstitute into normalization: \\[\n\\frac{\\lambda}{\\mu} P_1 + P_1 + \\frac{\\mu}{2\\lambda} P_1 = 1 \\Rightarrow P_1 \\left( \\frac{\\lambda}{\\mu} + 1 + \\frac{\\mu}{2\\lambda} \\right) = 1\n\\]\nSolve for \\(P_1\\), then: \\[\nP_{\\text{up}} = P_1 + P_2 = 1 - P_0\n\\]\nThis gives long-run availability of the system.\n\n\n\nExample 6.22 (Computer Virus Spread)\nA network of \\(n\\) computers. Any infected computer can infect any uninfected one at rate \\(\\lambda\\), and any infected computer gets cleaned at rate \\(\\mu\\).\nLet \\(X(t)\\) be the number of infected computers at time \\(t\\). Then \\(\\{X(t)\\}\\) is a birth–death process on states \\(0\\) to \\(n\\), with:\n\n\\(\\lambda_i = \\lambda i (n - i)\\): \\(i\\) infected can infect \\((n - i)\\) others\n\\(\\mu_i = \\mu i\\): each infected gets cleaned\n\nGoal: find the expected time to infection extinction starting from \\(i\\) infected computers.\nLet \\(m_i = \\mathbb{E}[\\text{time until absorption at 0} \\mid X(0) = i]\\)\nRecursion: \\[\nm_0 = 0 \\\\\nm_i = \\frac{1}{\\lambda_i + \\mu_i} + \\frac{\\lambda_i}{\\lambda_i + \\mu_i} m_{i+1} + \\frac{\\mu_i}{\\lambda_i + \\mu_i} m_{i-1}, \\quad i = 1, \\dots, n-1 \\\\\nm_n = \\frac{1}{\\mu_n} + m_{n-1}\n\\]\nThis is a standard way to compute expected hitting times in birth–death processes.\n\n\n\nApplication Notes\nThe above examples illustrate:\n\nModeling with CTMCs by carefully defining states and transition rates\nUsing limiting probabilities for long-run behavior\nUsing first-step analysis and recurrence relations to solve for expectations\nRelevance to systems reliability, networking, queueing, and more"
  },
  {
    "objectID": "src/modstok/latihan-soal/latihan-ctmc-1.html",
    "href": "src/modstok/latihan-soal/latihan-ctmc-1.html",
    "title": "📝 CTMC",
    "section": "",
    "text": "Program Studi: S1 Statistika / S1 Aktuaria\nMata Kuliah: Model Stokastik I\nSemester: ATA 2024/2025"
  },
  {
    "objectID": "src/modstok/latihan-soal/latihan-ctmc-1.html#soal-1-organisme-uniseluler-ctmc-dan-parameternya",
    "href": "src/modstok/latihan-soal/latihan-ctmc-1.html#soal-1-organisme-uniseluler-ctmc-dan-parameternya",
    "title": "📝 CTMC",
    "section": "🧪 Soal 1: Organisme Uniseluler – CTMC dan Parameternya",
    "text": "🧪 Soal 1: Organisme Uniseluler – CTMC dan Parameternya\n\n📄 Deskripsi Masalah\nMisalkan sebuah organisme uniseluler dapat berada dalam salah satu dari dua state – yaitu A atau B:\n\nIndividu dalam state A akan berubah menjadi B dengan laju eksponensial sebesar \\(\\alpha\\).\nIndividu dalam state B akan membelah menjadi dua individu baru A dengan laju eksponensial sebesar \\(\\beta\\).\n\n🧠 Tentukan:\n\nModel Continuous-Time Markov Chain (CTMC) yang sesuai.\nParameter-parameter model (laju waktu tunggu dan probabilitas transisi).\n\n\n\n\n🔢 Definisi State\nKita modelkan proses ini dengan dua state:\n\nState 1: Organisme berada dalam kondisi A\nState 2: Organisme berada dalam kondisi B\n\nWalaupun B membelah menjadi dua A, untuk tujuan model ini kita anggap transisinya tetap kembali ke state A karena hanya satu organisme aktif dalam satu waktu.\n\n\n\n🔁 Diagram Transisi\n[A] --α--&gt; [B] --β--&gt; [A]\n\nTransisi dari A ke B terjadi dengan rate \\(\\alpha\\)\nTransisi dari B ke A (hasil pembelahan) terjadi dengan rate \\(\\beta\\)\n\n\n\n\n📊 Matriks Generator (Q)\n\\[Q =\n\\begin{bmatrix}\n-\\alpha & \\alpha \\\\\n\\beta & -\\beta\n\\end{bmatrix}\\]\n\nBaris pertama: Transisi dari A ke B\nBaris kedua: Transisi dari B ke A\n\nSetiap baris menjumlahkan ke nol, seperti properti matriks generator CTMC.\n\n\n\n⏱️ Laju Waktu Tunggu\nWaktu tunggu untuk berpindah dari suatu state mengikuti distribusi eksponensial.\n\nDari state A: waktu tunggu \\(\\sim \\text{Exp}(\\alpha)\\) ⟶ \\(\\mathbb{E}[T_A] = \\frac{1}{\\alpha}\\)\nDari state B: waktu tunggu \\(\\sim \\text{Exp}(\\beta)\\) ⟶ \\(\\mathbb{E}[T_B] = \\frac{1}{\\beta}\\)\n\n\n\n\n🎲 Probabilitas Transisi Instan\nDalam CTMC, probabilitas transisi dari state \\(i\\) ke \\(j\\) setelah waktu tunggu adalah:\n\\[ P_{ij} = \\frac{q_{ij}}{-q_{ii}} \\]\nUntuk model ini:\n\n\\(P_{A \\to B} = \\frac{\\alpha}{\\alpha} = 1\\)\n\\(P_{B \\to A} = \\frac{\\beta}{\\beta} = 1\\)\n\nArtinya, transisi bersifat deterministik setelah waktu tunggu eksponensialnya berakhir.\n\n\n\n✅ Kesimpulan\n\nModel CTMC terdiri dari dua state (A dan B) dengan transisi bolak-balik.\nLaju waktu tunggu tergantung dari parameter \\(\\alpha\\) dan \\(\\beta\\).\nProbabilitas transisi dari A ke B dan B ke A adalah 1, karena tidak ada alternatif transisi lain."
  },
  {
    "objectID": "src/modstok/latihan-soal/latihan-ctmc-1.html#soal-2-dua-mesin-satu-teknisi-model-ctmc",
    "href": "src/modstok/latihan-soal/latihan-ctmc-1.html#soal-2-dua-mesin-satu-teknisi-model-ctmc",
    "title": "📝 CTMC",
    "section": "🛠️ Soal 2: Dua Mesin & Satu Teknisi – Model CTMC",
    "text": "🛠️ Soal 2: Dua Mesin & Satu Teknisi – Model CTMC\n\n📄 Deskripsi Masalah\nMisalkan terdapat dua mesin yang dirawat oleh satu orang teknisi. Detail sistem adalah sebagai berikut:\n\nMesin ke-\\(i\\) (dengan \\(i = 1, 2\\)) akan berfungsi selama waktu eksponensial dengan parameter \\(\\mu_i\\) sebelum rusak.\nHanya satu teknisi yang tersedia untuk memperbaiki satu mesin dalam satu waktu, dengan waktu perbaikan berdistribusi eksponensial dengan rate \\(\\mu\\).\n\n🧠 Tentukan:\n\nDefinisi state dan model CTMC.\nLaju waktu tunggu dan probabilitas transisi antar state.\n\n\n\n\n🔢 Definisi State\nKita akan definisikan state berdasarkan jumlah mesin yang rusak dan diperbaiki. Karena teknisi hanya bisa memperbaiki satu mesin sekaligus, maka maksimal satu mesin dapat diperbaiki dalam satu waktu.\nMari kita gunakan representasi state sebagai:\n\n\\(0\\): Kedua mesin berfungsi\n\\(1\\): Satu mesin rusak (belum diperbaiki)\n\\(R\\): Satu mesin sedang diperbaiki\n\\(2\\): Kedua mesin rusak (satu diperbaiki, satu menunggu)\n\\(F\\): Kedua mesin berfungsi kembali\n\nNamun untuk CTMC formal, kita gunakan representasi berikut:\n\n\n\nState\nDeskripsi\n\n\n\n\n0\nKedua mesin berfungsi\n\n\n1\nSatu mesin rusak, menunggu perbaikan\n\n\n2\nSatu mesin rusak sedang diperbaiki\n\n\n3\nDua mesin rusak, satu sedang diperbaiki, satu menunggu\n\n\n\n\n\n\n🔁 Diagram Transisi (Secara Umum)\n\n0 → 1: Salah satu mesin rusak (rate = \\(\\mu_1 + \\mu_2\\))\n1 → 2: Teknisi mulai memperbaiki (rate = instanasi teknisi atau penggabungan, bisa diasumsikan cepat)\n2 → 0: Mesin selesai diperbaiki (rate = \\(\\mu\\))\n2 → 3: Mesin lainnya rusak saat satu sedang diperbaiki (rate = \\(\\mu_i\\), tergantung mesin yang masih berfungsi)\n3 → 1: Satu mesin selesai diperbaiki (rate = \\(\\mu\\))\n\n\n\n\n📊 Matriks Generator (Q)\nMisalkan kita menyederhanakan state menjadi:\n\n\\(S_0\\): 0 mesin rusak\n\\(S_1\\): 1 mesin rusak (belum diperbaiki)\n\\(S_2\\): 1 mesin rusak (dalam perbaikan)\n\\(S_3\\): 2 mesin rusak (1 diperbaiki, 1 menunggu)\n\nAsumsikan:\n\n\\(\\mu_1 = \\mu_2 = \\lambda\\) (simetris)\nRate perbaikan oleh teknisi: \\(\\mu\\)\n\nMaka estimasi matriks \\(Q\\) bisa berbentuk:\n\\[Q =\n\\begin{bmatrix}\n-2\\lambda & 2\\lambda & 0 & 0 \\\\\n0 & -\\mu & \\mu & 0 \\\\\n\\lambda & 0 & -(\\lambda + \\mu) & \\lambda \\\\\n0 & \\mu & 0 & -\\mu \\\\\n\\end{bmatrix}\\]\n\n\n\n⏱️ Laju Waktu Tunggu\nUntuk setiap state, waktu tunggu mengikuti eksponensial dengan parameter sama dengan jumlah keluarannya (jumlah total rate keluar dari state itu).\nContoh:\n\nDari state 0: rate keluar \\(= \\mu_1 + \\mu_2 = 2\\lambda\\) ⟶ \\(\\mathbb{E}[T_0] = \\frac{1}{2\\lambda}\\)\nDari state 2: rate keluar \\(= \\mu + \\lambda\\) ⟶ \\(\\mathbb{E}[T_2] = \\frac{1}{\\mu + \\lambda}\\)\n\n\n\n\n🎲 Probabilitas Transisi\nProbabilitas dari state \\(i\\) ke \\(j\\) adalah:\n\\[P_{ij} = \\frac{q_{ij}}{-q_{ii}}\\]\nContoh:\n\nDari state 0 ke 1: \\(P_{01} = \\frac{2\\lambda}{2\\lambda} = 1\\)\nDari state 2:\n\nke state 0: \\(P_{20} = \\frac{\\mu}{\\lambda + \\mu}\\)\nke state 3: \\(P_{23} = \\frac{\\lambda}{\\lambda + \\mu}\\)\n\n\n\n\n\n✅ Kesimpulan\n\nModel CTMC memuat empat state utama, yaitu jumlah mesin rusak dan apakah sedang diperbaiki.\nMatriks generator Q menunjukkan kemungkinan transisi dan laju waktunya.\nWaktu tunggu antar state mengikuti distribusi eksponensial berdasarkan total laju keluar dari state tersebut.\nProbabilitas transisi dihitung sebagai rasio dari rate transisi terhadap total rate keluar.\n\n🧩 Untuk hasil paling akurat, semua perhitungan dapat disesuaikan jika \\(\\mu_1 \\ne \\mu_2\\)."
  },
  {
    "objectID": "src/modstok/latihan-soal/latihan-ctmc-1.html#soal-3-proses-kelahiran-dan-kematian-ekspektasi-variansi-waktu",
    "href": "src/modstok/latihan-soal/latihan-ctmc-1.html#soal-3-proses-kelahiran-dan-kematian-ekspektasi-variansi-waktu",
    "title": "📝 CTMC",
    "section": "👶⚰️ Soal 3: Proses Kelahiran dan Kematian – Ekspektasi & Variansi Waktu",
    "text": "👶⚰️ Soal 3: Proses Kelahiran dan Kematian – Ekspektasi & Variansi Waktu\n\n📄 Deskripsi Masalah\nDiberikan sebuah proses kelahiran-kematian (birth-death process) dengan:\n\nBirth rate: \\(\\lambda_i = (i + 1)\\lambda\\), untuk \\(i \\geq 0\\)\nDeath rate: \\(\\mu_i = i\\mu\\), untuk \\(i \\geq 0\\)\n\n🧠 Tentukan:\n\n\nNilai harapan waktu untuk berpindah dari state 2 ke 5\n\n\nVariansi dari waktu tersebut\n\n\n\n\n\n🔢 Definisi Umum\nProses kelahiran-kematian ini adalah CTMC dengan state numerik tak hingga \\(i = 0, 1, 2, \\dots\\)\nDengan:\n\nTransisi ke atas: \\(i \\to i+1\\) dengan laju \\(\\lambda_i = (i+1)\\lambda\\)\nTransisi ke bawah: \\(i \\to i-1\\) dengan laju \\(\\mu_i = i\\mu\\)\n\n\n\n\n🧮 (a) Ekspektasi Waktu dari State 2 ke 5\nMisalkan \\(m(i)\\) adalah ekspektasi waktu untuk mencapai state 5 dari state \\(i\\).\nGunakan pendekatan rekursif dengan sistem persamaan:\nUntuk \\(i \\neq 5\\):\n\\[m(i) = \\frac{1}{\\lambda_i + \\mu_i} + \\frac{\\lambda_i}{\\lambda_i + \\mu_i} m(i+1) + \\frac{\\mu_i}{\\lambda_i + \\mu_i} m(i-1)\\]\nDengan \\(m(5) = 0\\) (karena target sudah tercapai).\n\n\n🔁 Langkah Penyelesaian\nKarena diminta dari state 2 ke 5, kita bentuk sistem persamaan untuk \\(m(2), m(3), m(4)\\):\n\nHitung laju:\n\n\\(\\lambda_2 = 3\\lambda\\), \\(\\mu_2 = 2\\mu\\)\n\\(\\lambda_3 = 4\\lambda\\), \\(\\mu_3 = 3\\mu\\)\n\\(\\lambda_4 = 5\\lambda\\), \\(\\mu_4 = 4\\mu\\)\n\nBentuk sistem:\n\n\\[\\begin{aligned}\nm(4) &= \\frac{1}{9\\lambda} + \\frac{5\\lambda}{9\\lambda} m(5) + \\frac{4\\lambda}{9\\lambda} m(3) \\\\\n     &= \\frac{1}{9\\lambda} + 0 + \\frac{4}{9} m(3) \\\\\nm(3) &= \\frac{1}{7\\lambda} + \\frac{4\\lambda}{7\\lambda} m(4) + \\frac{3\\lambda}{7\\lambda} m(2) \\\\\n     &= \\frac{1}{7\\lambda} + \\frac{4}{7} m(4) + \\frac{3}{7} m(2) \\\\\nm(2) &= \\frac{1}{5\\lambda} + \\frac{3\\lambda}{5\\lambda} m(3) + \\frac{2\\lambda}{5\\lambda} m(1)\n\\end{aligned}\\]\nNamun karena kita hanya diminta menghitung waktu dari \\(2 \\to 5\\), kita bisa selesaikan secara bertahap mundur dengan substitusi ke belakang:\n\\[m(4) = \\frac{1}{9\\lambda}\\]\n\\[m(3) = \\frac{1}{7\\lambda} + \\frac{4}{7} m(4) = \\frac{1}{7\\lambda} + \\frac{4}{7} \\cdot \\frac{1}{9\\lambda}\n= \\frac{1}{7\\lambda} + \\frac{4}{63\\lambda} = \\frac{9 + 4}{63\\lambda} = \\frac{13}{63\\lambda}\\]\n\\[m(2) = \\frac{1}{5\\lambda} + \\frac{3}{5} m(3) + \\frac{2}{5} m(1)\\]\nTAPI kita tidak tahu \\(m(1)\\) karena \\(m(2)\\) adalah titik awal kita. Maka kita batasi hanya pada langkah-langkah menuju 5 tanpa kemunduran, yaitu hanya jalur 2 → 3 → 4 → 5 (asumsi tidak pernah turun, transient path approximation).\nMaka pendekatannya:\n\\[\\mathbb{E}[T_{2 \\to 3}] = \\frac{1}{\\lambda_2} = \\frac{1}{3\\lambda}, \\quad\n\\mathbb{E}[T_{3 \\to 4}] = \\frac{1}{\\lambda_3} = \\frac{1}{4\\lambda}, \\quad\n\\mathbb{E}[T_{4 \\to 5}] = \\frac{1}{\\lambda_4} = \\frac{1}{5\\lambda}\\]\n\\[\\Rightarrow \\mathbb{E}[T_{2 \\to 5}] = \\frac{1}{3\\lambda} + \\frac{1}{4\\lambda} + \\frac{1}{5\\lambda}\n= \\frac{20 + 15 + 12}{60\\lambda} = \\frac{47}{60\\lambda}\\]\n\n\n\n\n📏 (b) Variansi Waktu dari State 2 ke 5\nKarena waktu antar transisi adalah independen, variansi total adalah jumlah variansi per langkah:\n\\[\\text{Var}(T_{2 \\to 5}) = \\text{Var}(T_{2 \\to 3}) + \\text{Var}(T_{3 \\to 4}) + \\text{Var}(T_{4 \\to 5})\\]\nUntuk peubah acak eksponensial dengan rate \\(\\lambda\\), variansinya adalah \\(\\frac{1}{\\lambda^2}\\). Maka:\n\\[\\text{Var}(T_{2 \\to 3}) = \\frac{1}{(3\\lambda)^2}, \\quad\n\\text{Var}(T_{3 \\to 4}) = \\frac{1}{(4\\lambda)^2}, \\quad\n\\text{Var}(T_{4 \\to 5}) = \\frac{1}{(5\\lambda)^2}\\]\n\\[\\Rightarrow \\text{Var}(T_{2 \\to 5}) = \\frac{1}{9\\lambda^2} + \\frac{1}{16\\lambda^2} + \\frac{1}{25\\lambda^2}\n= \\frac{400 + 225 + 144}{3600\\lambda^2} = \\frac{769}{3600\\lambda^2}\\]\n\n\n\n✅ Kesimpulan\n\n💡 Ekspektasi waktu dari state 2 ke 5:\n\\[\\mathbb{E}[T_{2 \\to 5}] = \\frac{47}{60\\lambda}\\]\n📊 Variansi waktu dari state 2 ke 5:\n\\[\\text{Var}(T_{2 \\to 5}) = \\frac{769}{3600\\lambda^2}\\]\n\nCatatan: Perhitungan ini menggunakan pendekatan hanya jalur naik (tanpa kemunduran), cocok untuk pendekatan eksak bila transisi ke bawah tidak signifikan atau jika soal tidak menyertakan \\(\\mu\\) sebagai besar."
  },
  {
    "objectID": "src/modstok/latihan-soal/latihan-ctmc-1.html#soal-4-barbershop-kecil-ctmc-antrian-eksponensial",
    "href": "src/modstok/latihan-soal/latihan-ctmc-1.html#soal-4-barbershop-kecil-ctmc-antrian-eksponensial",
    "title": "📝 CTMC",
    "section": "💈 Soal 4: Barbershop Kecil – CTMC Antrian Eksponensial",
    "text": "💈 Soal 4: Barbershop Kecil – CTMC Antrian Eksponensial\n\n📄 Deskripsi Masalah\nSebuah barbershop kecil hanya memiliki satu tukang cukur dan kapasitas maksimal 2 pelanggan di dalam. Detail sistem:\n\nPelanggan datang menurut proses Poisson dengan laju \\(3\\) orang per jam.\nWaktu pelayanan masing-masing pelanggan adalah eksponensial, rata-rata \\(\\frac{1}{4}\\) jam (artinya, laju pelayanan \\(\\mu = 4\\) pelanggan/jam).\nTidak ada ruang tunggu tambahan — pelanggan yang datang saat barbershop penuh akan pergi.\n\n🧠 Tentukan:\n\n\nJumlah rata-rata pelanggan dalam barbershop\n\n\nProporsi pelanggan potensial yang berhasil masuk\n\n\nTambahan bisnis jika tukang cukur bekerja 2× lebih cepat\n\n\n\n\n\n🧮 Step 1: Definisi Parameter\n\nLaju Kedatangan: \\(\\lambda = 3\\)/jam\n\nLaju Pelayanan: \\(\\mu = 4\\)/jam\n\nState Sistem:\n\n\\(0\\): Tidak ada pelanggan\n\n\\(1\\): 1 pelanggan (sedang dicukur)\n\n\\(2\\): 2 pelanggan (1 dicukur, 1 antri)\n\n\n\n\n\n📝 Step 2: Persamaan Keseimbangan\nUntuk probabilitas stasioner \\(\\pi_0, \\pi_1, \\pi_2\\):\n1. Dari state 0:\n\\[\n   \\lambda \\pi_0 = \\mu \\pi_1 \\quad \\Rightarrow \\quad \\pi_1 = \\frac{3}{4} \\pi_0\n   \\]\n2. Dari state 1:\n\\[\n   (\\lambda + \\mu) \\pi_1 = \\lambda \\pi_0 + \\mu \\pi_2 \\quad \\Rightarrow \\quad 7\\pi_1 = 3\\pi_0 + 4\\pi_2\n   \\]\n3. Dari state 2:\n\\[\n   \\mu \\pi_2 = \\lambda \\pi_1 \\quad \\Rightarrow \\quad \\pi_2 = \\frac{9}{16} \\pi_0\n   \\]\n\n\n\n🧮 Step 3: Hitung Probabilitas Stasioner\nSubstitusi ke \\(\\pi_0 + \\pi_1 + \\pi_2 = 1\\):\n\\[\n\\pi_0 \\left(1 + \\frac{3}{4} + \\frac{9}{16}\\right) = 1 \\quad \\Rightarrow \\quad \\pi_0 = \\frac{16}{37}, \\quad \\pi_1 = \\frac{12}{37}, \\quad \\pi_2 = \\frac{9}{37}\n\\]\n\n\n\n📊 Hasil Analisis\n\n\n\n\n\n\n\n\nParameter\nFormula\nNilai\n\n\n\n\nRata-Rata Pelanggan\n\\(0\\pi_0 + 1\\pi_1 + 2\\pi_2\\)\n\\(\\frac{30}{37} \\approx 0.81\\)\n\n\nProporsi Pelanggan Masuk\n\\(1 - \\pi_2\\)\n\\(\\frac{28}{37} \\approx 75.7\\%\\)\n\n\nPeningkatan Efisiensi ((= 8))\n\\(\\pi_2' = \\frac{9}{97}\\)\n\\(\\text{Kenaikan } 15\\%\\)\n\n\n\n\n\n\n\n\n\n\nCara Lain\n\n\n\n\n\n\n🔢 Definisi State\nKita definisikan state \\(i\\) sebagai jumlah pelanggan di dalam barbershop (termasuk yang sedang dicukur):\n\n\n\nState \\(i\\)\nDeskripsi\n\n\n\n\n\\(0\\)\nTidak ada pelanggan\n\n\n\\(1\\)\n1 pelanggan (dalam servis)\n\n\n\\(2\\)\n2 pelanggan (1 diservis, 1 menunggu)\n\n\n\n\n\n\n🔁 Diagram Transisi (CTMC)\n\nKedatangan pelanggan (Poisson, \\(\\lambda = 3\\) per jam)\nPelayanan pelanggan (Eksponensial, \\(\\mu = 4\\) per jam)\n\nTransisi:\n[0] --λ--&gt; [1] --λ--&gt; [2]\n ↑         ↓μ         ↓μ\n ←---------←----------←\n\n\n\n📊 Matriks Generator (Q)\n\\[Q =\n\\begin{bmatrix}\n-3 & 3 & 0 \\\\\n4 & -7 & 3 \\\\\n0 & 4 & -4\n\\end{bmatrix}\\]\nBaris \\(i\\) mewakili laju keluar dari state \\(i\\), dan kolom mewakili tujuan transisi.\n\n\n\n🔍 Distribusi State Stasioner (π)\nKita gunakan keseimbangan global untuk mencari probabilitas stasioner \\(\\pi_0\\), \\(\\pi_1\\), \\(\\pi_2\\).\n\\[\\begin{aligned}\n\\pi_1 &= \\frac{\\lambda}{\\mu} \\pi_0 = \\frac{3}{4} \\pi_0 \\\\\n\\pi_2 &= \\frac{\\lambda}{\\mu} \\pi_1 = \\frac{3}{4} \\cdot \\frac{3}{4} \\pi_0 = \\left( \\frac{3}{4} \\right)^2 \\pi_0 = \\frac{9}{16} \\pi_0\n\\end{aligned}\\]\nGunakan kondisi total probabilitas:\n\\[\\pi_0 + \\pi_1 + \\pi_2 = 1\n\\Rightarrow \\pi_0 + \\frac{3}{4} \\pi_0 + \\frac{9}{16} \\pi_0 = 1\n\\Rightarrow \\pi_0 \\left(1 + \\frac{3}{4} + \\frac{9}{16} \\right) = 1\n\\Rightarrow \\pi_0 \\cdot \\frac{61}{16} = 1\n\\Rightarrow \\pi_0 = \\frac{16}{61}\\]\nSehingga:\n\\[\\pi_1 = \\frac{3}{4} \\cdot \\frac{16}{61} = \\frac{48}{61}, \\quad\n\\pi_2 = \\frac{9}{16} \\cdot \\frac{16}{61} = \\frac{9}{61}\\]\n\n\n\n🧮 (a) Rata-rata Pelanggan di Barbershop\n\\[\\mathbb{E}[N] = 0 \\cdot \\pi_0 + 1 \\cdot \\pi_1 + 2 \\cdot \\pi_2 = 0 + \\frac{48}{61} + 2 \\cdot \\frac{9}{61} = \\frac{48 + 18}{61} = \\frac{66}{61} \\approx 1.082\\]\n\n\n\n🚪 (b) Proporsi Pelanggan yang Berhasil Masuk\nPelanggan hanya ditolak saat state = 2. Jadi proporsi yang berhasil masuk:\n\\[1 - \\pi_2 = 1 - \\frac{9}{61} = \\frac{52}{61} \\approx 0.852\\]\nArtinya, sekitar 85.2% pelanggan berhasil masuk ke barbershop.\n\n\n\n⚡ (c) Tukang Cukur Bekerja 2× Lebih Cepat\nJika \\(\\mu = 8\\) (bukan 4):\n\\[\\rho = \\frac{\\lambda}{\\mu} = \\frac{3}{8}\\]\nHitung ulang distribusi stasioner:\n\\[\\pi_1 = \\frac{3}{8} \\pi_0, \\quad\n\\pi_2 = \\left( \\frac{3}{8} \\right)^2 \\pi_0 = \\frac{9}{64} \\pi_0\\]\n\\[\\pi_0 + \\pi_1 + \\pi_2 = \\pi_0 \\left(1 + \\frac{3}{8} + \\frac{9}{64} \\right)\n= \\pi_0 \\cdot \\frac{121}{64} = 1\n\\Rightarrow \\pi_0 = \\frac{64}{121}\\]\n\\[\\pi_2 = \\frac{9}{64} \\cdot \\frac{64}{121} = \\frac{9}{121}\n\\Rightarrow \\text{Proporsi masuk} = 1 - \\frac{9}{121} = \\frac{112}{121} \\approx 0.926\\]\n🧮 Tambahan bisnis:\n\\[\\text{Tambahan proporsi masuk} = \\frac{112}{121} - \\frac{52}{61} = \\approx 0.926 - 0.852 = 0.074\\]\nArtinya, ada peningkatan pelanggan masuk sekitar 7.4% jika tukang cukur bekerja dua kali lebih cepat.\n\n\n\n\n\n\n\n✅ Kesimpulan\n\n📊 Rata-rata pelanggan dalam barbershop: \\(\\frac{66}{61} \\approx 1.082\\)\n🚶 Proporsi pelanggan yang berhasil masuk: \\(\\frac{52}{61} \\approx 85.2\\%\\)\n⚡ Jika tukang cukur lebih cepat 2×, proporsi masuk naik jadi \\(\\approx 92.6\\%\\) (kenaikan ~7.4%)"
  },
  {
    "objectID": "src/modstok/rantai-markov-waktu-kontinu.html#fungsi-probabilitas-transisi",
    "href": "src/modstok/rantai-markov-waktu-kontinu.html#fungsi-probabilitas-transisi",
    "title": "rantai markov waktu kontinu",
    "section": "6.4 Fungsi Probabilitas Transisi",
    "text": "6.4 Fungsi Probabilitas Transisi\nMisalkan \\[P_{ij}(t) = \\mathbb{P}\\{X(t + s) = j \\mid X(s) = i\\}\\] denotasikan probabilitas bahwa process ada di keadaan \\(i\\) akan berada di keadaan \\(j\\) setelah \\(t\\) waktu. Kuantitas ini yang sering disebut probabilitas transisi dari rantai markov waktu kontinu.\nKita dapat secara eksplisit menentukan \\(P_{ij}(t)\\) dalam proses kasus kelahiran murni yang memiliki rate kelahiran distinct. Untuk sebuah proses, misal \\(X_k\\) dinotasikan lama waktu proses menghabiskan di keadaan \\(k\\) sebelum berpindah ke keadaan \\(k+1\\), \\(k&gt;=1\\). Asumskan proses ada di keadaan \\(i\\) dan misalkan \\(j&gt; i\\). Maka, ketika \\(X_i\\) adalah lama waktu yang dihabiskan di keadaan \\(i\\) sebelum bergerak ke keadaan \\(i+1\\), dan \\(X_{i+1}\\) adalah lama waktu yang dihabiskan di keadaan \\(i+1\\) sebelum bergerak ke keadaan \\(i+2\\), dan seterusnya, mengikuti \\[sum_{k=i}^{j-1} X_k = X_i + X_{i+1} + X_{i+2} + \\cdots + X_{j-1}\\] adalah lama waktu yang dibutuhkan sebelum proses masuk ke keadaan \\(j\\). Sekarang, jika proses belum masuk ke keadaan \\(j\\) pada waktu \\(t\\), maka itu sama aja bilang keadaan \\(t\\) lebih kecil dari \\(j\\), dan sebaliknya. Atau kalo secara matematis ditulisnya \\[X(t)&lt;j \\iff X_i + \\cdots + X_{j-1} &gt; t\\]. Oleh karenanya, untuk \\(i&lt;j\\) proses kelahiran murni, kita punya \\[\n\\begin{align*}\n\\mathbb{P}\\{X(t) &lt; j \\mid X(0) = i\\} &= \\mathbb{P}\\left\\{ \\sum_{k=i}^{j-1} X_k &gt; t \\right\\} \\\\\n&= \\mathbb{P}\\left\\{ X_i + X_{i+1} + X_{i+2} + \\cdots + X_{j-1} &gt; t\\right\\}\n\\end{align*}\n\\]"
  }
]